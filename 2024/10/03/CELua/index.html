<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CELua | Meng's blog</title><meta name="author" content="Meng"><meta name="copyright" content="Meng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="Cheat Engine Lua">
<meta property="og:type" content="article">
<meta property="og:title" content="CELua">
<meta property="og:url" content="https://blog.mengkr.asia/2024/10/03/CELua/index.html">
<meta property="og:site_name" content="Meng&#39;s blog">
<meta property="og:description" content="Cheat Engine Lua">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg">
<meta property="article:published_time" content="2024-10-03T13:50:45.000Z">
<meta property="article:modified_time" content="2025-01-09T04:54:51.502Z">
<meta property="article:author" content="Meng">
<meta property="article:tag" content="lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.mengkr.asia/2024/10/03/CELua/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章最后更新于","messageNext":"天前，可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CELua',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-01-09 12:54:51'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">47</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">28</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Meng's blog"><span class="site-name">Meng's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CELua</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-03T13:50:45.000Z" title="发表于 2024-10-03 21:50:45">2024-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-01-09T04:54:51.502Z" title="更新于 2025-01-09 12:54:51">2025-01-09</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming/">programming</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/">Reverse</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h1><p>TrainerOrigin：包含启动CE的训练器路径的变量（仅在作为训练器启动时设置）<br>process：包含当前打开的进程的主模块名称的变量<br>MainForm：主 ce gui<br>AddressList：主 ce gui 的地址列表</p>
<h1 id="全局函数"><a href="#全局函数" class="headerlink" title="全局函数"></a>全局函数</h1><p>getCEVersion()：返回指定版本的浮点值<br>getCheatEngineFileVersion()：返回CE版本的完整版本数据。原始整数，以及包含主要版本、次要版本、发布版本和构建版本的表格</p>
<p>getOperatingSystem()：对于 Windows 返回 0，对于 Mac 返回 1</p>
<p>darkMode()：如果 CE 在 Windows 暗模式下运行，则返回 true。对 Mac 没有影响</p>
<p>activateProtection()：防止基本内存扫描仪打开CE进程（不太有用）<br>enableDRM(altitude OPTIONAL, secondaryprocessid OPTIONAL )：防止普通内存扫描仪读取CE进程（内核模式）secondaryprocessid 可让您保护另一个进程。例如游戏本身，这样他们就无法轻易看到你所做的更改</p>
<p>fullAccess(address,size)：将内存块的保护更改为可写和可执行</p>
<p>loadTable(filename,merge OPTIONAL)：加载 .ct 或 .cetrainer。如果提供了 merge 并将其设置为 true，则不会清除旧表<br>loadTable(stream,merge OPTIONAL,ignoreluascriptdialog BOOLEAN)：从流对象加载表<br>saveTable(filename,protect OPTIONAL,dontDeactivateDesignerForms OPTIONAL)：保存当前表。如果提供了 protect 并将其设置为 true，并且文件名具有 .CETRAINER 扩展名，它将保护它不被正常读取<br>saveTable(stream, dontDeactivateDesignerForms OPTIONAL)：将当前表保存到流对象</p>
<p>signTable(filename)：如果当前 CE 安装具有有效的 cheta 引擎签名，这将使用该签名对特定表进行签名（将弹出密码请求）</p>
<p>注意：地址可以是字符串，它们将由 ce 的符号处理程序进行解释</p>
<p>copyMemory(sourceAddress: integer, size: integer, destinationAddress:integer SEMIOPTIONAL, Method:integer OPTIONAL):<br>将内存从给定地址复制到目标地址<br>如果未指定目标地址（或为 nil），CE 将为您分配一个随机地址</p>
<p>方法可以是：<br>nil&#x2F;0：从目标进程复制到目标进程<br>1：从目标进程复制到 CE 内存<br>2：从 CE 内存复制到目标进程<br>3：从 CE 内存复制到 CE 内存</p>
<p>成功时返回复制的地址，失败时返回 nil</p>
<p>compareMemory(address1: integer; address2: integer; size: integer; method: integer)<br>比较内存，如果相同则返回 true，否则返回 false 以及第一个差异所在的索引</p>
<p>方法可以是：<br>0：目标到目标<br>1：地址 1&#x3D;目标地址 2&#x3D;CE<br>2：地址 1&#x3D;CE 地址 2&#x3D;CE</p>
<p>readBytes(address,bytecount, ReturnAsTable ) ：返回给定地址处的字节。如果 ReturnAsTable 为真，它将返回一个表而不是多个字节<br>读取给定地址处的字节并返回包含读出字节的表</p>
<p>writeBytes(address, x,x,x,x,…) ：将给定字节从表中写入给定地址<br>writeBytes(address, table) ：将给定字节从表中写入给定地址</p>
<p>readShortInteger(address) &#x2F; readByte(address) ：从指定地址读取 8 位整数<br>readSmallInteger(address) ：从指定地址读取 16 位整数<br>readInteger(address) ：从指定地址读取 32 位整数<br>readQword(address)：从指定地址读取 64 位整数<br>readPointer(address)：在 64 位目标中，这等于 readQword，在 32 位目标中，这等于 readInteger()<br>readFloat(address) ：从指定地址读取单精度浮点值<br>readDouble(address) ：从指定地址读取双精度浮点值<br>readString(address, maxlength, widechar 可选) ：读取字符串直到遇到 0 终止符。Maxlength 只是为了让您不会冻结太久，如果您不太在意，请设置为 6000。如果使用 widechar 格式进行编码，请将 WideChar 设置为 true<br>writeShortInteger(address,value) &#x2F; writeByte(address,value) ：将 16 位整数写入指定地址。成功时返回 true<br>writeSmallInteger(address,value) ：将 16 位整数写入指定地址。成功时返回 true<br>writeInteger(address,value) ：将 32 位整数写入指定地址。成功时返回 true<br>writeQword(address, value)：将 64 位整数写入指定地址。成功时返回 true<br>writePointer(address,value)<br>writeFloat(address,value) ：将单精度浮点写入指定地址。成功则返回 true<br>writeDouble(address,value) ：将双精度浮点写入指定地址。成功则返回 true<br>writeString(address,text, widechar OPTIONAL) ：将字符串写入指定地址。成功则返回 true</p>
<p>readBytesLocal(address,bytecount, ReturnAsTable) : 参见 readBytes，但它适用于 Cheat 引擎的内存<br>readSmallIntegerLocal(address) : 从 CE 内存中的指定地址读取一个 16 位整数<br>readIntegerLocal(address) : 从 CE 内存中的指定地址读取一个 32 位整数<br>readQwordLocal(address) : 从 CE 内存中的指定地址读取一个 64 位整数<br>readPointerLocal(address) : ReadQwordLocal&#x2F;ReadIntegerLocal 取决于 cheat 引擎的构建<br>readFloatLocal(address) : 从 CE 内存中的指定地址读取一个单精度浮点值<br>readDoubleLocal(address) : 从 CE 内存中的指定地址读取一个双精度浮点值<br>readStringLocal(address, maxlength, widechar OPTIONAL)<br>writeSmallIntegerLocal(address,value) :将 16 位整数写入 CE 内存中的指定地址。成功时返回 true<br>writeIntegerLocal(address,value) ：将 32 位整数写入 CE 内存中的指定地址。成功时返回 true<br>writeQwordLocal(address,value) ：将 64 位整数写入 CE 内存中的指定地址。成功时返回 true<br>writePointerLocal(address,value)<br>writeFloatLocal(address,value) ：将单精度浮点数写入 CE 内存中的指定地址。成功时返回 true<br>writeDoubleLocal(address,value) ：将双精度浮点数写入 CE 内存中的指定地址。成功时返回 true<br>writeStringLocal(address,string, widechar OPTIONAL)<br>writeBytesLocal(address, x,x,x,x,…) : 参见 writeBytes，但它是针对 Cheat Engine 的内存的<br>writeBytesLocal(address, table, , count) : 参见 writeBytes，但它是针对 Cheat Engine 的内存的</p>
<p>readSmallInteger、readInteger、readSmallIntegerLocal、readIntegerLocal<br>也可以有第二个布尔参数。如果为 true，则值将被签名。</p>
<p>signExtend(value,mostSignificantBit): 整数 - 扩展位，这样如果设置了 MSB 位，它将为负数</p>
<p>wordToByteTable(number): {} - 将字转换为字节表<br>dwordToByteTable(number): {} - 将双字转换为字节表<br>qwordToByteTable(number): {} - 将四字转换为字节表<br>floatToByteTable(number): {} - 将浮点转换为字节表<br>doubleToByteTable(number): {} - 将双精度转换为字节表<br>extendedToByteTable(number): {} - 将扩展转换为字节表<br>stringToByteTable(string): {} - 将字符串转换为字节表<br>wideStringToByteTable(string): {} - 将字符串转换为宽字符串并将其转换为字节表</p>
<p>byteTableToWord(table, OPTIONALsigned:boolean): number - 将字节表转换为word<br>byteTableToDword(table, OPTIONALsigned:boolean): number - 将字节表转换为 dword<br>byteTableToQword(table): number - 将字节表转换为 qword<br>byteTableToFloat(table): number - 将字节表转换为浮点数<br>byteTableToDouble(table): number - 将字节表转换为双精度数<br>byteTableToExtended(table): number - 将字节表转换为扩展数并将其转换为双精度数<br>byteTableToString(table): string - 将字节表转换为字符串<br>byteTableToWideString(table): string - 将字节表转换为宽字符串并将其转换为字符串</p>
<p>bOr(int1, int2) : 二进制或<br>bXor(int1, int2) : 二进制异或<br>bAnd(int1, int2) : 二进制与<br>bShl(int, int2) : 二进制左移<br>bShr(int, int2) : 二进制右移<br>bNot(int) : 二进制非</p>
<p>enumMemoryRegions() : 返回包含内存布局的索引表。每个条目由以下部分组成：BaseAddress、AllocationBase、AllocationProtect、RegionSize、State、Protect、Type</p>
<p>writeRegionToFile(filename, sourceaddress,size) : 将给定区域写入文件。返回写入的字节数<br>readRegionFromFile(filename, destinationaddress)</p>
<p>resetLuaState()：这将创建一个将要使用的新 lua 状态。 （不会销毁旧的，因此会造成内存泄漏）</p>
<p>createRef(…): 整数 - 返回可以与 getRef 一起使用的整数引用。对于只能存储整数并需要引用 lua 对象的对象很有用。（Component.Tag…）<br>getRef(整数): … - 返回引用指向的内容<br>destroyRef(整数) - 删除引用</p>
<p>encodeFunction(函数): 字符串 - 将给定函数转换为可以传递给解码函数的编码字符串<br>decodeFunction(字符串): 函数 - 将编码字符串转换回函数。请注意，字符串必须在与当前运行相同的体系结构上制作。32 位只能加载 32 位，64 位只能加载 64 位。因此，要么准备好两个脚本，要么限制为仅一个体系结构。（如 .EXE 训练器）</p>
<p>encodeFunctionEx(string,pathtodll 可选) - 参见 encodeFunction，但使用脚本而不是函数，并允许您指定要使用哪个 lua dll（注意：仍然不能在 64 位中使用 32 位 dll，反之亦然）</p>
<p>getTranslationFolder()：返回当前翻译文件的路径。如果没有正在进行翻译，则为空<br>loadPOFile(path)：加载用于翻译的 .PO 文件<br>translate(string)：返回字符串的翻译。如果找不到则返回相同的字符串<br>translateID(translationid: string, originalstring: string OPTIONAL): 返回字符串 id 的翻译</p>
<p>ansiToUtf8(string): 将 Ansi 编码的字符串转换为 UTF8<br>utf8ToAnsi(string): 将 UTF8 编码的字符串转换为 Ansi<br>注意：GUI 组件主要以 UTF8 显示，其他一些函数使用 Ansi，尝试找出哪些…</p>
<p>enumModules(processid OPTIONAL):<br>返回一个表，其中包含有关当前进程或指定进程 ID 中每个模块的信息<br>每个条目都是一个带有字段的表<br>Name : 包含模块名称的字符串<br>Address: 表示模块加载地址的整数<br>Is64Bit: 如果是 64 位模块，则设置为 true 的布尔值<br>PathToFile: 指向此模块加载位置的字符串</p>
<p>md5memory(address, size): 返回根据提供的内存计算出的 md5 总和。<br>md5file(pathtofile): 返回根据文件计算出的 md5 和。<br>getFileVersion(pathtofile): 返回 64 位文件版本，以及将文件版本分为主要版本、次要版本、发行版本和内部版本的表格</p>
<p>getFileList(Path:string, searchMask:string OPTIONAL, SearchSubDirs: boolean OPTIONAL, DirAttrib: integer OPTIONAL): 返回带有文件名的索引表<br>getDirectoryList(Path:string, SearchSubDirs: boolean OPTIONAL): 返回带有目录名的索引表<br>extractFileName(filepath): 返回路径的文件名<br>extractFileExt(filepath): 返回路径的文件扩展名<br>extractFileNameWithoutExt(filepath): 返回路径的文件名，不带扩展名<br>extractFilePath(filepath): 从路径中删除文件名</p>
<p>enableWindowsSymbols(): 将下载 Windows 的 PDB 文件并加载它们（第一次需要很长时间）<br>getAddress(string, local OPTIONAL): 返回符号的地址。可以是模块名称或导出。如果您希望查询 ce 进程的符号表，请将 Local 设置为 true<br>enableKernelSymbols()：将检查内存视图中内核模式符号的选项（除非使用 enableWindowsSymbols()，否则仅获取导出）<br>getAddressSafe(string, local OPTIONAL, shallow OPTIONAL)：返回符号的地址，如果未找到则返回 nil。当 errorOnLookup 为 false 时，与 getAddress 类似，但返回 nil<br>getSymbolInfo(symbolname)：返回 SymbolList 类对象定义的表（modulename、searchkey、address、size）<br>getModuleSize(modulename)：返回给定模块的大小（使用 getAddress 获取基地址）<br>getRTTIClassName(address)：根据 RTTI 信息返回给定结构的类名（假设可以找到，如果找不到或未知则返回 nil）</p>
<p>reinitializeSymbolhandler(waittilldone：BOOLEAN OPTIONAL，默认值为 TRUE)：重新初始化 symbolhandler。例如，当加载了新模块时<br>reinitializeDotNetSymbolhandler(modulename OPTIONAL)：仅重新初始化符号列表的 DotNet 部分。 （例如，在 ILCode 经过 JIT 处理后）（6.4+）<br>reinitializeSelfSymbolhandler（waittilldone：BOOLEAN OPTIONAL，默认值为 TRUE）：重新初始化 selfsymbolhandler。例如，当新模块已加载到 CE 进程时<br>waitForSections()：等待直到枚举完节<br>waitForExports()：等待直到加载所有 DLL 导出<br>waitForDotNet()：等待直到加载所有 .NET 符号（这包括 DLL 导出）<br>waitForPDB()：等待直到加载所有 PDB 符号（这包括 DLL 导出和 .NET）<br>searchPDBWhileLoading（state：boolean）：将中断符号枚举以查询有关特定符号的 debughelp 符号处理程序。这可能需要一段时间。默认值为 false</p>
<p>errorOnLookupFailure(state)：如果设置为 true（默认），则以字符串形式查找地址时如果无法查找，则会引发错误。这包括未定义的符号名称和错误的指针。如果设置为 false，则在这些情况下将返回 0<br>（对于 100% 时间都不起作用的指针很有用）<br>6.4+：返回原始状态</p>
<p>waitforsymbols(state)：如果设置为 true，则查找符号将等待符号加载（默认为 true）</p>
<p>generateAPIHookScript(address:string, addresstojumpto:string, addresstogetnewcalladdress:string OPT, ext:string OPT, targetself:boolean OPT)：生成自动汇编程序脚本，该脚本将在执行时挂接给定的地址<br>assemble(line, address OPTIONAL, assemblePreference OPTIONAL, skipRangeCheck OPTIONAL)：汇编一行代码并返回生成代码的字节数组。<br>address 是汇编此代码的地址<br>assemblePreference: apNone&#x3D;0, apShort&#x3D;1, apLong&#x3D;2, apFar&#x3D;3<br>skipRangeCheck 是布尔值。如果为真，将跳过范围检查并直接汇编，无论结果有多么错误<br>autoAssemble(text, targetself OPTIONAL, disableInfo OPTIONAL) ：使用给定的文本运行自动汇编程序。成功时返回 true，并在禁用时使用辅助表（如果设置了 targetself，它将汇编到 Cheat Engine 本身中）。如果提供了 disableInfo，将处理 [Disable] 部分<br>autoAssemble(text, disableInfo OPTIONAL)</p>
<p>autoAssembleCheck(text, enable, targetself) ：检查脚本是否存在语法错误。成功则返回 true，失败则返回 false 并显示错误消息</p>
<p>compile(text, address OPTIONAL, targetself OPTIONAL) : 编译 C 代码并返回一个包含符号地址的表，如果成功，则返回 nil 并返回包含错误消息的次要结果<br>compile({indexedtable including scripts}, address OPTIONAL, targetself OPTIONAL) ) : ^ 但允许将多个脚本编译为一个脚本<br>compileFiles({filelist}, address OPTIONAL, targetself OPTIONAL) ): ^ 但采用文件的索引列表<br>compileTCCLib() - 编译某些 C 代码可能需要内部运行的 TCC 库函数</p>
<p>addCIncludePath(path) : 为 compile() 函数添加额外的默认包含路径<br>removeCIncludePath(path) : 删除之前使用 addCIncludePath 添加的特定路径</p>
<p>compileCS(text, {references}, coreAssembly OPTIONAL) - 编译 c#代码并返回自动生成的文件名。references 是此代码可能引用的 c# 程序集列表。当 CE 关闭时（或下次另一个 CE 关闭并且不再使用时），此文件将被删除。注意：这需要安装 .NET 4，即使目标是 mono。提示：使用injectDotNetDLL非常方便<br>dotNetExecuteClassMethod(pathtodll, namespace, classname, methodname, parameters: string): integer - 在 CE 内部，调用声明为 .NET 类中的方法：public static int methodname(string parameters) 对于目标进程版本，请查看injectDotNetDLL</p>
<p>registerEXETrainerFeature(FeatureName:String, function():table)：向 exe 训练器生成器窗口添加新功能，并在用户构建 .exe 训练器时调用您的函数。该函数应返回一个包含表条目的表：PathToFile 和 RelativePath。<br>示例输出：<br>[1]：<br>PathToFile&#x3D;c:\cefolder\autorun\mycode.lua<br>RelativePath&#x3D;”autorun&quot;</p>
<p>[2]：<br>PathToFile&#x3D;c:\cefolder\autorun\dlls\mycode.lua<br>RelativePath&#x3D;”autorun\mylib.dll”</p>
<p>注意：此操作在表已打包后运行</p>
<p>unregisterEXETrainerFeature(id)</p>
<p>registerAutoAssemblerCommand(command, function(parameters, syntaxcheckonly))：注册自动汇编器命令以调用指定函数。该命令将被此函数执行时返回的字符串替换。该函数可以调用两次。一次用于语法检查和符号查找 (1)，第二次用于汇编器实际执行 (2)（如果在阶段 1 中没有被删除）。<br>注意：回调函数可以返回多个值<br>Nil，<String>：将使用给定的字符串引发错误<br>MultilineString：用给定的字符串替换脚本中的行。</p>
<p>如果函数返回 nil，并且次要参数为字符串，则会导致自动汇编程序失败并出现该错误</p>
<p>unregisterAutoAssemblerCommand(command)</p>
<p>registerLuaFunctionHighlight(functionname)：使 lua 高亮器将函数名称显示为函数关键字</p>
<p>unregisterLuaFunctionHighlight(functionname)：删除给定名称，使其不显示为函数关键字</p>
<p>registerSymbolLookupCallback(function(string):integer, location)：ID 6.4+<br>注册一个函数，在解析符号时调用该函数<br>位置决定在符号查找的哪个部分调用该函数<br>slStart：符号查找的开始。在标记化之前<br>slNotInt：在确定它不是十六进制字符串时调用。标记化之前<br>–以下位置可以针对一个字符串多次调用，因为它们会针对每个标记和附加标记调用<br>slNotModule：当确定当前标记不是模块名称时调用<br>slNotUserdefinedSymbol：当确定它不是用户定义符号时调用<br>slNotSymbol：当确定它不是符号列表中的符号时调用<br>slFailure：当不知道给定的字符串是什么时调用</p>
<p>注意：slNotSymbol 和 slFailure 类似，但仅当当前标记之后没有可以连接的标记时才会失败。否则 slNotSymbol 将循环多次，直到所有标记组成完整的字符串</p>
<p>如果找到，则返回具有相应地址的整数。如果没有找到，则返回 Nil 或 0。</p>
<p>unregisterSymbolLookupCallback(ID): 删除回调</p>
<p>registerAddressLookupCallback(function(integer):string): ID<br>注册一个函数，当请求地址名称时调用</p>
<p>unregisterAddressLookupCallback(ID): 删除回调</p>
<p>registerStructureAndElementListCallback(function StructureListCallback(), function elementlistcallback(id1,id2) ) : 注册一个函数，当需要剖析结构时调用<br>function StructureListCallback() 将是一个以表格格式返回结构列表数组的函数<br>条目构建如下：<br>name: string - 结构名称<br>id1: integer - 可用于任何用途的 id（例如 moduleid）。当选择此结构时，它将传递给 elementlistcallback<br>id2: integer - 可用于任何用途的 id（例如模块内的 structureid）。当选择此结构时，它将被传递给 elementlistcallback</p>
<p>function elementlistcallback(id1,id2) 将是一个以表格格式返回结构元素数组的函数<br>条目构建为：<br>name: string<br>offset: integer<br>vartype: variabletype (查找 vtByte、vtWord 等)</p>
<p>提示：如果返回一个空表，则不会创建结构。您可以使用它自己创建结构布局并注册它</p>
<p>unregisterStructureAndElementListCallback(ID)</p>
<p>registerStructureDissectOverride(function(structure, baseaddress): table):<br>与 onAutoGuess 相同，但当用户选择让欺骗引擎为他猜测结构时，结构剖析窗口会调用该函数。<br>使用结构对象进行填充<br>如果已填充，则返回 true，否则返回 false 或 nil</p>
<p>提示：如果函数没有自动执行此操作，则使用 inputQuery 询问用户大小</p>
<p>unregisterStructureDissectOverride(ID)</p>
<p>registerStructureNameLookup(function(address): name, address OPTIONAL):<br>注册一个函数，当剖析数据向用户询问新结构定义的名称时，将调用该函数。如果您有可以查找结构名称的代码，并且可能还有真正的起点，则可以使用它来改进数据剖析。</p>
<p>unregisterStructureNameLookup(ID)</p>
<p>registerAssembler(function(address, instructions):bytetable)<br>注册一个函数，当单行汇编器被调用来将指令转换为字节列表时，该函数将被调用<br>返回一个包含特定字节的字节表，或者如果您希望让另一个函数或原始 x86 汇编器对其进行汇编，则返回 nil</p>
<p>unregisterAssembler(ID)：取消注册已注册的汇编器</p>
<p>registerAutoAssemblerPrologue(function(script, syntaxcheck), postAOB:boolean&#x3D;false)<br>注册一个函数，当自动汇编器即将解析自动汇编器脚本时，该函数将被调用。您获得的脚本是在使用 [ENABLE] 和 [DISABLE] 标签将脚本剥离为相应脚本之后，但在注释剥离和修剪之前</p>
<p>脚本是一个字符串对象，当更改时会对脚本产生直接影响</p>
<p>unregisterAutoAssemblerPrologue(ID)</p>
<p>registerAutoAssemblerTemplate(name, function(script: TStrings; sender: TFrmAutoInject), 快捷方式 OPTIONAL ): id - 为自动汇编程序注册一个模板。脚本参数是一个与当前脚本有直接连接的 TStrings 对象。（所有脚本解析都由您决定…）。返回 ID<br>unregisterAutoAssemblerTemplate(ID)</p>
<p>generateCodeInjectionScript(script: Tstrings, address: string, farjmp: boolean) - 向给定脚本添加默认代码注入脚本<br>generateAOBInjectionScript(script: Tstrings, symbolname: string, address: string, commentradius(default 10), farjmp: boolean) - 向给定脚本添加 AOB 注入脚本<br>generateFullInjectionScript(script: Tstrings, address: string, commentradius(default 10), farjmp: boolean) - 向给定脚本添加完整注入脚本</p>
<p>getNextAllocNumber(script: TStrings): integer - 扫描给定脚本中的 alloc(newmem## 并返回下一个未使用的 newmem 编号)<br>addSnapshotAsComment(script: TStrings, address: integer, radius(Default 10)) - 为包含快照的 AA 脚本创建注释部分原始代码<br>getUniqueAOB(address): AOBString,Offset - 扫描给定地址的唯一 AOB 并以字符串形式返回 AOB，如果返回的 aob 不是从给定地址开始，则应用偏移量</p>
<p>showMessage(text) ：显示带有给定文本的消息框<br>inputQuery(caption, prompt, initialstring)：显示一个对话框，用户可以在其中输入字符串。此函数返回给定的字符串，或在取消时返回 nil<br>showSelectionList(title, caption, stringlist, allowCustomInput OPTIONAL): integer,string - 显示带有给定列表的菜单。它返回行号（从 0 开始）和选定的字符串。如果允许用户输入自定义输入，则 Linenumber 为 -1</p>
<p>messageDialog(text, type, buttons…) ：弹出带有特定图标&#x2F;声音的消息框，并带有指定按钮（mbok、mbyes 等）</p>
<p>messageDialog(title, text, type, buttons…)：^ 但添加了自定义标题</p>
<p>messageDialog(text) ：显示带有文本的信息对话框</p>
<p>sleep(milliseconds)：暂停指定的毫秒数（1000&#x3D; 1 秒…）</p>
<p>getProcesslist(Strings)：使用系统的进程列表填充 Strings 继承对象。格式：%x-pidname</p>
<p>getProcesslist()：返回包含进程列表（pid - name）的表格</p>
<p>getWindowlist(Strings)：使用系统的顶级窗口列表填充 Strings 继承对象。格式：%x-windowcaption</p>
<p>getWindowlist()：返回包含窗口列表（pid - 窗口标题）的表格。该表的格式为：{pid,{id,caption}}</p>
<p>getThreadlist(List)：用当前打开的进程的线程列表填充 List 对象。格式：%x<br>getHandleList(filter OPTIONAL)：返回一个包含系统中所有句柄的表（过滤器 0&#x3D;所有内容，1&#x3D;仅目标进程句柄，2 个句柄指向目标进程，3 个句柄指向 ce 进程）。每个句柄条目都有字段：ProcessID、ObjectTypeIndex、HandleAttributes、HandleValue、Object 和 GrantedAccess。注意：如果在 64 位 Windows 上使用 32 位 CE，则对象将无效</p>
<p>closeRemoteHandle(handle, processid 可选): 关闭进程的句柄。</p>
<p>duplicateHandle(handle): 将提供的基于 CE 的句柄复制到目标进程中（您仍需要将此句柄告知目标，如注入的 dll 数据块）<br>duplicateHandle(handle, Mode (0&#x2F;1) ): 如果模式为 0，则它与 duplicateHandle(handle) 相同，但如果为 1，它会将目标进程句柄复制到 CE 的进程中<br>duplicateHandle(handle, fromPID, toPID): 将句柄从给定进程复制到目标进程。</p>
<p>function onOpenProcess(processid):<br>如果定义了此函数，则每当 cheat engine 打开进程时都会调用它。<br>注意：内部可能会连续多次打开同一个进程<br>注意 2：在完全完成连接之前会调用此函数。您可以调用 reinitializeSymbolhandler() 来强制完成打开，但这会减慢进程打开的速度。或者，您可以启动一个计时器，该计时器将在打开完成后运行</p>
<p>MainForm.OnProcessOpened：函数（processid、processhandle、caption）- 如果您希望在打开新进程时收到通知，请定义此函数。仅从主线程调用一次。建议使用此函数而不是 onOpenProcess</p>
<p>函数 onTableLoad(before)：如果定义，则在加载表时将调用此函数两次。一次在加载之前，一次在加载之后。</p>
<p>getOpenedProcessID() ：返回当前打开的进程。如果没有打开，则返回 0<br>getOpenedProcessHandle()：返回当前打开的进程的句柄<br>getProcessIDFromProcessName(name)：返回进程 ID<br>openProcess(processid)：使欺骗引擎打开给定的进程 ID<br>openProcess(processname)：使欺骗引擎查找并打开给定的进程<br>openFileAsProcess(filename,is64bit OPTIONAL,startaddress OPTIONAL)：使欺骗引擎打开具有内存访问的文件，就像它是一个进程一样<br>saveOpenedFile(filename OPTIONAL)：保存打开文件的更改，如果您想要不同的文件，请设置文件名<br>setPointerSize(size)：设置欺骗引擎将处理指针的大小（以字节为单位）。 （某些 64 位进程只能使用 32 位地址）<br>setAssemblerMode(int)：0&#x3D;32 位，1&#x3D;64 位<br>pause()：暂停当前打开的进程<br>unpause()：恢复当前打开的进程</p>
<p>getCPUCount()：返回 CPU 的数量<br>cpuid(EAX,ECX)：返回包含 CPUID 信息的表（EAX、EBX、ECX、EDX）</p>
<p>gc_setPassive(state：boolean)：启用&#x2F;禁用被动垃圾收集器<br>gc_setActive(state：boolean，interval：integer，minsize：integer)：启用&#x2F;禁用主动垃圾收集器并允许您配置间隔和最小大小</p>
<p>getSystemMetrics(index)：检索指定的系统指标或系统配置设置<br>(<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385.aspx">https://msdn.microsoft.com/en-us/library/windows/desktop/ms724385.aspx</a>)</p>
<p>getScreenDPI()：返回屏幕的每英寸点数&#x2F;像素数</p>
<p>getScreenHeight()：返回屏幕高度</p>
<p>getScreenWidth()：返回屏幕宽度</p>
<p>getWorkAreaHeight()：返回工作区高度</p>
<p>getWorkAreaWidth()：返回工作区宽度</p>
<p>getScreenCanvas()：返回可用于写入屏幕的 Canvas 对象（注意：可能没有您想象的那么有用）</p>
<p>getPixel(x,y)：返回特定屏幕坐标处像素的 rgb 值</p>
<p>getMousePos：返回鼠标的 x,y 坐标</p>
<p>setMousePos(x,y)：设置鼠标位置</p>
<p>isKeyPressed(key)：如果当前按下了指定键，则返回 true<br>keyDown(key)：使键变为向下状态状态<br>keyUp(key) ：使键向上移动<br>doKeyPress(key) ：模拟按键</p>
<p>mouse_event(flags, x 可选, y 可选, data 可选, extra 可选) - mouse_event windows API。查看 MSDN 了解如何使用</p>
<p>shortCutToText(shortcut)：返回给定快捷键值的文本表示形式（整数）（6.4+）<br>textToShortCut(shortcutstring)：返回给定字符串表示的快捷键整数。（6.4+）</p>
<p>convertKeyComboToString(key1,…)：返回给定键的字符串表示形式，如热键处理程序所做的那样<br>convertKeyComboToString({key1,…})：^</p>
<p>outputDebugString(text)：使用 windows OutputDebugString 消息输出消息。您可以使用 dbgview 等工具来读取此消息。适用于测试 GUI 冻结的情况</p>
<p>shellExecute(command, parameters OPTIONAL, folder OPTIONAL, showcommand OPTIONAL): 执行给定的命令</p>
<p>getTickCount()：返回自 Windows 启动以来的当前滴答计数。每个滴答为一毫秒<br>processMessages()：让主事件处理程序处理新消息（允许新的按钮点击）<br>inMainThread()：如果当前代码在主线程内运行，则返回 true（6.4+）<br>integerToUserData(int)：将给定的整数转换为用户数据变量<br>userDataToInteger(UserDataVar)：将给定的用户数据变量转换为整数</p>
<p>synchronize(function(…), …)：从主线程调用给定函数。返回给定函数的返回值<br>queue(function(…),…)：从主线程调用给定函数。不等待结果。注意：在释放调用线程之前，请务必同步并调用 checkSynchronize()<br>checkSynchronize（timeout 可选）：使用线程和同步调用时，从主线程中的无限循环调用此函数。这将执行任何排队的同步调用</p>
<p>writeToClipboard(text)：将给定的文本写入剪贴板</p>
<p>readFromClipboard()：从剪贴板读取文本</p>
<p>speedhack_setSpeed(speed)：如果需要，启用 speedhack 并设置特定速度</p>
<p>speedhack_getSpeed()：返回最后设置的速度</p>
<p>injectDLL(filename, skipsymbolreloadwait OPTIONAL)：注入 dll 或 dylib，并在成功时返回 true</p>
<p>injectLibrary(filepath, skipsymbolreloadwait OPTIONAL)：与 injectionDLL 相同，只是听起来更好</p>
<p>injectDotNetDLL(dllpath, FullClassName, MethodName,parameterstring, timeout 可选)</p>
<p>executeCode(address, paramter OPTIONAL, timeout OPTIONAL) : address - 在目标进程中的给定地址处执行具有 1 个参数的 stdcall 函数并等待它返回。返回值是调用函数的结果</p>
<p>executeCodeLocal(addres, 参数可选): address - 在目标进程中给定的地址执行带有 1 个参数的 stdcall 函数。返回值是调用函数的结果</p>
<p>executeCodeEx(callmethod, timeout, address, {type&#x3D;x,value&#x3D;param1} 或 param1,{type&#x3D;x,value&#x3D;param2} 或 param2,…)<br>callmethod: 0&#x3D;stdcall, 1&#x3D;cdecl<br>timeout: 等待结果的毫秒数。nil 或 -1，无限。 0 表示不等待（不会释放调用内存，因此请注意内存泄漏）<br>address：要执行的地址<br>{type,value} ：包含值类型和值的表<br>{<br>type：0&#x3D;整数（32&#x2F;64 位）也可以是指针<br>1&#x3D;浮点数（32 位浮点数）<br>2&#x3D;双精度数（64 位浮点数）<br>3&#x3D;ascii 字符串（将转换为指向该字符串的指针）<br>4&#x3D;宽字符串（将转换为指向该字符串的指针）</p>
<p>value：lua 可以解释的任何基本类型<br>}<br>如果仅提供 param，CE 将根据提供的类型猜测类型</p>
<p>executeMethod(callmethod, timeout, address, {regnr&#x3D;0..15,classinstance&#x3D;xxxxxxxx} 或 classinstance, {type&#x3D;x,value&#x3D;param1} 或 param1, {type&#x3D;x,value&#x3D;param2} 或 param2,…) -执行一个方法。<br>regnr 可以是：<br>0：R&#x2F;EAX<br>1：R&#x2F;ECX<br>2：R&#x2F;EDX<br>3：R&#x2F;EBX<br>4：R&#x2F;ESP<br>5：R&#x2F;EBP<br>6：R&#x2F;ESI<br>7：R&#x2F;EDI<br>8：R8<br>9：R9<br>10：R10<br>11：R11<br>12：R12<br>13：R13<br>14：R14<br>15：R15</p>
<p>如果没有提供寄存器编号，则选择 ECX(1)<br>如果实例为零，则与 executeCodeEx 相同</p>
<p>executeCodeLocalEx(address, {type&#x3D;x,value&#x3D;param1} 或 param1,{type&#x3D;x,value&#x3D;param2} 或 param2,…)<br>使用给定的 callmethod 和参数调用函数</p>
<p>如果给出直接参数而不是描述类型的表条目，CE 将“猜测”类型</p>
<p>返回被调用函数返回的 E&#x2F;RAX 值（如果没有超时或其他中断）</p>
<p>loadPlugin(dllnameorpath)：加载给定的插件。失败时返回 nil。成功时返回 0 或更大的值</p>
<p>loadFontFromStream(memorystream)：从内存流加载字体并返回字体的 id（句柄）以供 unloadLoadedFont 使用<br>unloadLoadedFont(id)</p>
<p>onAutoGuess(function)：<br>注册一个函数，每当使用自动猜测来预测变量类型时都会调用该函数<br>function override (address, ceguess)：返回您想要的变量类型。如果没有变化，则返回 ceguess</p>
<p>closeCE() ：仅关闭 ce<br>hideAllCEWindows() ：使所有正常 ce 窗口不可见（例如训练表）<br>unhideMainCEwindow() ：显示主欺骗引擎窗口</p>
<p>getAutoAttachList()：返回 AutoAttach StringList 对象。可以使用 stringlist_ 例程进行控制（不建议销毁此列表对象）</p>
<p>AOBScan(x,x,x,x,…)：<br>扫描当前打开的进程并返回包含所有结果的 StringList 对象。完成后不要忘记释放此列表<br>高于 255 的字节值或任何非整数的值都将被视为通配符<br>AOBScan(aobstring, OPTIONAL protectionflags, OPTIONAL alignmenttype, OPTIONAL alignmentparam): 参见上文，但此处只需输入一个字符串<br>AOBScanUnique(aobstring, OPTIONAL protectionflags, OPTIONAL alignmenttype, OPTIONAL alignmentparam)- 整数：扫描 aobstring 并返回找到的第一个结果，如果没有找到则返回 nil。确保它是唯一的，因为它将返回找到的第一个结果，因为它将返回任何随机匹配<br>AOBScanModuleUnique(modulename, aobstring, OPTIONAL protectionflags, OPTIONAL alignmenttype, OPTIONAL alignmentparam)- 整数：扫描指定模块中的 aobstring</p>
<p>关于事件处理程序。您可以使用函数名称的字符串或函数本身来初始化它们。<br>如果使用函数本身进行初始化，它将无法保存在表中</p>
<p>allocateMemory（size，BaseAddress OPTIONAL，Protection OPTIONAL）：将一些内存分配到目标进程<br>deAlloc（address，size OPTIONAL）：释放分配的内存</p>
<p>allocateSharedMemory（name，size）：<br>如果尚不存在，则在给定大小的附加进程中创建一个共享内存对象。如果没有指定大小，并且没有具有此名称的共享区域，则使用默认大小 4096<br>然后它将此共享内存块映射到当前目标进程中。它返回目标进程中此映射区域的地址。请记住，一个进程可以多次映射同一个块，因此请跟踪您的分配<br>allocateSharedMemoryLocal（名称，大小）：与 allocateSharedMemory 相同，但针对 Cheat Engine 进程本身</p>
<p>createSection（size）：在内存中创建一个“部分”<br>mapViewOfSection（section，preferedBaseAddress OPTIONAL）：将部分映射到内存<br>unMapViewOfSection（baseaddress）：从内存中取消部分映射</p>
<p>getForegroundProcess（）：返回当前位于顶部的进程的进程 ID</p>
<p>findWindow（classname OPTIONAL，caption OPTIONAL）：windowhandle - 查找具有给定类名和&#x2F;或窗口名的窗口<br>getWindow（windowhandle，command）：windowhandle - 根据给定窗口获取特定窗口（查看 MSDN getWindow 了解命令说明）<br>getWindowCaption（windowhandle）：string - 返回窗口的标题<br>getWindowClassName（windowhandle）：string - 返回窗口的类名<br>getWindowProcessID(windowhandle): processid - 返回此窗口所属进程的进程 ID<br>getForegroundWindow() - windowhandle ：返回最顶层窗口的窗口句柄</p>
<p>sendMessage(hwnd, msg, wparam, lparam): result - 向窗口发送消息。想要使用它的人应该知道如何使用它（并自己填写 msg id）<br>hookWndProc(hwnd, function(hwnd, msg, wparam, lparam), ASYNC: BOOL) - 挂钩窗口的 wndproc 过程。给定函数将接收所有函数。返回 0 表示您已处理它。返回 1 表示让默认窗口处理程序处理它。或者其他任何内容，让原始处理程序处理它。除了返回值之外，您还可以返回 hWnd、Msg、lParam 和 wParam、修改后的或 nil 作为原始值。如果您不想在 CE GUI 中运行此程序，请将 ASYNC 设置为 true。（速度更快，但您无法接触 gui 对象）<br>unhookWndProc(hwnd) - 完成挂钩后调用此函数。不调用此函数将导致退出 CE 时进程窗口行为异常</p>
<p>cheatEngineIs64Bit()：如果 CE 是 64 位，则返回 true，如果是 32 位，则返回 false</p>
<p>targetIs64Bit()：如果目标进程是 64 位，则返回 true，如果是 32 位，则返回 false</p>
<p>getCheatEngineDir()：返回 Cheat Engine 所在的文件夹</p>
<p>getCheatEngineProcessID()：返回 cheat engine 的进程 ID</p>
<p>getAutorunPath()：返回自动运行路径</p>
<p>getUserDocumentsPath()：返回用户文档文件夹的路径。</p>
<p>disassemble(address)：反汇编给定的地址并返回一个字符串，格式为“地址 - 字节 - 操作码：extra”<br>splitDisassembledString(disassembledstring)：返回 4 个字符串。地址、字节、操作码和 extra 字段</p>
<p>getInstructionSize(address)：返回指令的大小（基本上它会反汇编指令并为您返回字节数）<br>getPreviousOpcode(address)：返回前一个操作码的地址（这只是一个估计的猜测）</p>
<p>beep()：播放美妙的哔哔声&#x2F;ping 声！<br>playSound(stream, waittilldone OPTIONAL)：播放包含 .WAV 格式内存对象的给定内存流。如果 waittilldone 为真，脚本将停止执行，直到声音停止<br>playSound(tablefile, waittilldone OPTIONAL)：从表文件中获取内存流并播放。<br>作弊引擎中预先声明了两个表文件“Activate”和“Deactivate”。您可以自由使用或覆盖它们</p>
<p>speak(text, waittilldone OPTIONAL)：朗读给定的文本。如果 waitTillDone 为真，则其所在的线程将被冻结，直到完成<br>speak(text, flags)：使用给定的标志朗读给定的文本。<a target="_blank" rel="noopener" href="https://msdn.microsoft.com/en-us/library/speechplatform_speakflags.aspx">https://msdn.microsoft.com/en-us/library/speechplatform_speakflags.aspx</a><br>speakEnglish(text, waittilldone OPTIONAL) - 将通过将给定的文本包装到指定英语语音的 XML 语句中来尝试英语语音。如果没有英语语言，则不会说话。不要使用 SPF_IS_NOT_XML 标志，SPF_PARSE_SSML 在这种情况下不起作用</p>
<p>printf(…) ：与 print(string.format(…)) 相同<br>setProgressState(state)：设置任务栏中 cheatengine 任务的状态（仅限 Windows）值：tbpsNone、tbpsIndeterminate、tbpsNormal、tbpsError、tbpsPaused<br>setProgressValue(current, max)：设置 cheatengine 任务进度状态</p>
<p>getUserRegistryEnvironmentVariable(name): string - 返回存储在用户注册表环境中的环境变量<br>setUserRegistryEnvironmentVariable(name, string) - 设置存储在用户注册表环境中的环境变量<br>当您更改注册表中的环境变量时。这至少会导致 shell 更新，因此您不必重新启动。（但始终建议重新启动）</p>
<p>stringToMD5String(string)：从提供的字符串返回 md5 哈希字符串</p>
<p>getFormCount()：返回分配给主 CE 应用程序的表单总数</p>
<p>getForm(index)：返回特定索引处的表单</p>
<p>registerFormAddNotification(function(form))：注册一个函数，当表单附加到 ce 的表单列表时调用该函数。这对于向某些现有表单添加新功能的扩展非常有用。它返回一个可以与 unregisterFormAddNotification 一起使用的对象<br>unregisterFormAddNotification(Object)</p>
<p>getSettingsForm()：返回主设置表单<br>getMemoryViewForm()：返回主内存视图表单类对象，可以使用 Form_ 类方法和它继承的类的方法进行访问。可以有多个内存视图，但这只会找到原始&#x2F;基础<br>getMainForm()：返回主表单类对象，可以使用 Form 类方法和它继承的类的方法进行访问</p>
<p>getApplication()：返回应用程序对象。（标题栏）<br>getAddressList()：返回备忘单地址列表对象<br>getFreezeTimer()：返回冻结计时器对象<br>getUpdateTimer()：返回更新计时器对象</p>
<p>setGlobalKeyPollInterval(integer)：设置全局键盘轮询间隔。间隔决定了 CE 检查按键是否被按下的频率。越低越准确，但消耗的 CPU 功率越多<br>setGlobalDelayBetweenHotkeyActivation（整数）：设置激活相同热键之间的最小延迟（以毫秒为单位）。影响所有未设置其自身最小延迟的热键</p>
<p>getXBox360ControllerState（ControllerID OPTIONAL）：表 - 获取连接的 Xbox 控制器的状态。成功时返回包含以下字段的表：<br>ControllerID：控制器的 ID（介于 0 和 3 之间）<br>PacketNumber：您看到的状态的数据包 ID。 （用于检测变化）<br>GAMEPAD_DPAD_UP ：方向键向上（布尔值）<br>GAMEPAD_DPAD_DOWN：方向键向下（布尔值）<br>GAMEPAD_DPAD_LEFT：方向键向左（布尔值）<br>GAMEPAD_DPAD_RIGHT：方向键向右（布尔值）<br>GAMEPAD_START：开始按钮（布尔值）<br>GAMEPAD_BACK：后退按钮（布尔值）<br>GAMEPAD_LEFT_THUMB：左拇指摇杆向下（布尔值）<br>GAMEPAD_RIGHT_THUMB：右拇指摇杆向下（布尔值）</p>
<p>GAMEPAD_LEFT_SHOULDER：左肩按钮（布尔值）<br>GAMEPAD_RIGHT_SHOULDER：右肩按钮（布尔值）</p>
<p>GAMEPAD_A：A 按钮（布尔值）<br>GAMEPAD_B：B 按钮（布尔值）<br>GAMEPAD_X：X 按钮（布尔值）<br>GAMEPAD_Y：Y 按钮（布尔值）</p>
<p>LeftTrigger：左触发器（范围从 0 到 255 的整数）<br>RightTrigger：右触发器（范围从 0 到 255 的整数）</p>
<p>ThumbLeftX：左拇指杆的水平位置（-32768 到 32767）<br>ThumbLeftY：左拇指杆的垂直位置（-32768 到 32767）<br>ThumbRightX：右拇指杆的水平位置（-32768 到 32767）<br>ThumbRightY：右拇指杆的垂直位置（-32768 到 32767）</p>
<p>setXBox360ControllerVibration（ControllerID、leftMotor、rightMotor）- 设置控制器内左右振动马达的速度。范围（0 到 65535，其中 0 表示关闭）</p>
<p>connectToCEServer（主机名、端口）- 连接到给定的主机和端口。成功后，大多数后续命令将由服务器处理。例如进程列表、内存读取等…</p>
<p>未定义的属性函数。并非所有类的所有属性都已明确暴露给 lua，但如果您知道特定类的属性名称，您仍然可以访问它们（假设它们在 pascal 类声明中声明为已发布）<br>getPropertyList(class) ：返回一个包含指定类的所有已发布属性的字符串列表对象（完成后释放列表）（注意，并非所有具有属性的类都具有“已发布”属性。例如：stringlist）<br>setProperty(class, propertyname, propertyvalue) ：设置类的已发布属性的值（不适用于方法属性）<br>getProperty(class, propertyname) ：获取类的已发布属性的值（不适用于方法属性）<br>setMethodProperty(class, propertyname, function)：将方法属性设置为特定函数<br>getMethodProperty(Class, propertyname)：返回可用于调用原始函数的函数</p>
<p>registerSymbol(symbolname, address, OPTIONAL) donotsave)：注册用户定义的符号。如果 donotsave 为真，则在保存表时不会保存此符号<br>unregisterSymbol(symbolname)</p>
<p>getNameFromAddress(address,ModuleNames OPTIONAL&#x3D;true, Symbols OPTIONAL&#x3D;true, Sections OPTIONAL&#x3D;false): 返回给定地址作为字符串。根据地址的不同，返回已注册的符号名称、模块名称 + 偏移量或十六进制字符串<br>inModule(address) : 如果给定地址位于模块内，则返回 true<br>inSystemModule(address) : 如果给定地址位于系统模块内，则返回 true<br>getCommonModuleList: 返回 commonModuleList 字符串列表。（不要释放此字符串）</p>
<p>AOBScan(“aobstring”, protectionflags OPTIONAL, alignmenttype OPTIONAL, alignmentparam HALFOPTIONAL):<br>protectionflags 是字符串。<br>X&#x3D;可执行 W&#x3D;可写内存 C&#x3D;写时复制。添加 + 表示必须设置该标志，添加 - 表示不得设置该标志。 (* 将其设置为无关)<br>示例：<br>+W-C &#x3D; 可写内存，不包括写时复制，并且不关心可执行标志<br>+X-C-W &#x3D; 查找只读可执行内存<br>+W &#x3D; 查找所有可写内存，不关心写时复制或执行<br>“” &#x3D; 查找所有内容（与 “<em>X</em>C*W” 相同）</p>
<p>alignmenttype 是一个整数：<br>0&#x3D;无对齐检查<br>1&#x3D;地址必须能被 alignmentparam 整除<br>2&#x3D;地址必须以 alignmentparam 结尾<br>alignmentparam 是一个字符串，它要么保存地址必须能被整除的值，要么保存地址的最后几位数字</p>
<p>-debugging</p>
<p>调试变量<br>EFLAGS<br>32&#x2F;64 位：EAX、EBX、ECX、EDX、EDI、ESI、EBP、ESP、EIP<br>仅限 64 位：RAX、RBX、RCX、RDX、RDI， RSI、RBP、RSP、RIP、R8、R9、R10、R11、R12、R13、R14、R15：寄存器的值</p>
<p>调试相关例程：<br>函数 debugger_onBreakpoint()：<br>当断点命中（包括单步执行）且定义了 lua 函数 debugger_onBreakpoint() 时，将调用该函数并填充全局变量 EAX、EBX、…</p>
<p>如果您希望更新用户界面，则返回 0，否则返回其他值（例如：您从脚本中的断点继续执行）</p>
<p>createProcess(path、parameters OPTIONAL、debug OPTIONAL、breakonentrypoint OPTIONAL)：创建一个进程。如果 debug 为真，则将使用 windows 调试器创建，如果 breakonentry 为真，则将导致在入口点发生断点</p>
<p>debugProcess(interface OPT)：为当前打开的进程启动调试器（不会询问用户）可选接口：0&#x3D;默认，1&#x3D;windows 调试，2&#x3D;VEHDebug，3&#x3D;Kerneldebug</p>
<p>debug_isDebugging()：如果调试器已启动，则返回 true<br>debug_getCurrentDebuggerInterface()：返回当前使用的调试器接口（1&#x3D;windows，2&#x3D;VEH 3&#x3D;Kernel，nil&#x3D;没有激活调试）<br>debug_canBreak()：如果目标有可能在断点处停止，则返回 true。 6.4+<br>debug_isBroken()：如果调试器当前在线程上暂停，则返回 true<br>debug_getBreakpointList()：返回包含所有断点地址的 lua 表<br>debug_breakThread(threadid)：中断具有特定线程 ID 的线程（注意：线程可能不会立即中断，可能必须先唤醒）</p>
<p>debug_addThreadToNoBreakList(threadid)：这将导致忽略所提供线程上的断点<br>debug_removeThreadFromNoBreakList(threadid)：从列表中删除线程 ID</p>
<p>debug_setBreakpointForThread(threadid, address, size OPTIONAL, trigger OPTIONAL, breakpointmethod OPTIONAL, functiontocall() OPTIONAL)：在指定线程的给定地址处设置特定大小的断点。如果触发器为 bptExecute，则忽略大小。如果忽略触发器，则它将是 bptExecute 类型，这显然也会忽略大小。（其他触发器是 bptAccess 和 bptWrite）<br>debug_setBreakpoint(address, size OPTIONAL, trigger OPTIONAL, breakpointmethod OPTIONAL, functiontocall() OPTIONAL)<br>debug_setBreakpoint(address, size OPTIONAL, trigger OPTIONAL, functiontocall() OPTIONAL)<br>debug_setBreakpoint(address, functiontocall() OPTIONAL)<br>debug_removeBreakpoint(address) : 如果给定的地址是断点的一部分，它将被删除<br>debug_continueFromBreakpoint(continueMethod) : 如果调试器当前正在等待继续，您可以继续执行此操作。有效参数为：co_run（继续）、co_stepinto（在调用顶部时，跟随它）、co_stepover（在调用顶部时运行直到调用结束）<br>debug_getXMMPointer(xmmregnr)：<br>返回当前中断的线程的指定 xmm 寄存器的地址<br>这是本地作弊引擎地址。使用本地内存访问函数读取和修改<br>xmmregnr 可以是 0 到 15（32 位上为 0 到 7）</p>
<p>以下例程描述了最后一个分支记录。这些函数仅在使用内核模式调试并使用 Windows XP 时有效（Vista 及更高版本工作效率较低或根本不工作，因为操作系统会干扰。也可能是英特尔特有的。将来的 dbvm 升级可能会使此功能适用于 Windows Vista 及更高版本）<br>debug_setLastBranchRecording（布尔值）：设置后，内核调试器将尝试记录断点发生前执行的最后一个分支<br>debug_getMaxLastBranchRecord()：返回 CPU 可以存储的最大分支记录（如果没有，则为 -1）<br>debug_getLastBranchRecord（index）：返回给定索引处的最后一个分支记录的值（处理断点时）</p>
<p>function debugger_onModuleLoad（modulename，baseaddress）：<br>加载模块时调用此例程。仅适用于 Windows 调试器<br>如果要使调试器中断，请返回 1</p>
<p>更改寄存器：<br>当调试器等待继续时，您可以更改寄存器变量。继续时，这些寄存器值将在线程的上下文中设置</p>
<p>如果目标当前在断点处停止，但未通过 onBreakpoint 函数完成。上下文不会被设置。<br>您可以在继续执行之前使用这些函数获取和设置上下文”<br>debug_getContext(BOOL extraregs) - 填充常规寄存器的全局变量。如果 extraregs 为真，它还会将 FP0 设置为 FP7，将 XMM0 设置为 XMM15<br>debug_setContext(BOOL extraregs)<br>debug_updateGUI() - 如果调试器损坏，将刷新用户界面以反映新上下文</p>
<p>detachIfPossible() ：将调试器与目标进程分离（如果已连接）</p>
<p>getComment(address) ：获取指定地址处的用户定义注释<br>setComment(address, text) ：在指定地址处设置用户定义注释。如果有自动猜测值，则使用 %s 显示该值<br>getHeader(address) ：获取指定地址处的用户定义标头<br>setHeader(address) ：在指定地址处设置用户定义标头</p>
<p>registerBinUtil(config) 寄存器带有 CE 的 binutils 工具集（用于在其他 CPU 指令集中进行汇编和反汇编）<br>config 是一个包含多个字段的表，用于描述工具，并允许您指定额外参数</p>
<p>名称：memview 中 binutils 菜单中显示的名称<br>说明：此工具集的说明<br>架构：由 objdump -m<architecture> 使用（必需）<br>ASParam：传递给 AS 的额外参数（可选）<br>LDParam：传递给 LD 的额外参数<br>OBJDUMPParam：传递给 OBJDUMP 的额外参数<br>OnDisassemble：每次反汇编地址时都会调用的 lua 函数。返回值将传递给 OBJDUMP<br>路径：binutils 集的文件路径<br>前缀：前缀（例如：“arm-linux-androideabi-”）<br>DisassemblerCommentChar：根据您要反汇编的目标，注释字符可能会有所不同。 （ARM&#x3D;”；” x86&#x3D;’#’）</p>
<h1 id="类"><a href="#类" class="headerlink" title="类"></a>类</h1><p>Control Class：（继承：组件-&gt;对象）<br>属性：<br>Caption：字符串 - 控件的文本<br>Top：整数 - x 位置<br>Left：整数 - y 位置<br>Width：整数 - 控件的宽度<br>Height：整数 - 控件的高度<br>ClientWidth：整数 - 控件内可用的宽度（减去边框）<br>ClientHeight：整数 - 控件可用的高度（减去边框）<br> Align：AlignmentOption - 控件的对齐方式<br>Enabled：布尔值 - 确定对象是否可用或变灰<br>Visible：布尔值 - 确定对象是否可见<br>Color：ColorDefinition&#x2F;RGBInteger - 对象的颜色。不影响标题<br>RGBColor：RGBInteger - RGB 格式的对象颜色<br>Parent：WinControl - 此控件的所有者<br>PopupMenu：PopupMenu - 右键单击控件时显示的弹出菜单<br>Font：Font - 与控件关联的字体类<br>OnClick：function(sender) - 按下按钮时调用的函数<br>OnChangeBounds：function(sender) - 控件的大小或位置发生变化时调用</p>
<p>methods：<br>getLeft()<br>setLeft(integer)<br>getTop()<br>setTop(integer)<br>getWidth()<br>setWidth(integer)<br>getHeight()<br>setHeight()<br>setCaption(caption) ：设置控件上的文本。所有 GUI 对象都属于此类别<br>getCaption() ：返回控件的文本<br>setPosition(x,y)：设置对象基点在左上角位置的 x 和 y 位置（相对于所有者对象的客户端数组）<br>getPosition()：返回对象的 x 和 y 位置（相对于所有者对象的客户端数组）<br>setSize(width,height) ：设置控件的宽度和高度<br>getSize() ：获取控件的大小<br>setAlign(alignmentoption)：设置控件的对齐方式<br>getAlign(alignmentoption)：获取控件的对齐方式<br>getEnabled() ：获取控件的启用状态<br>setEnabled(boolean) ：设置控件的启用状态<br>getVisible() ：获取控件的可见状态<br>setVisible(boolean) ：设置控件的可见状态<br>getColor() ：获取颜色<br>setColor(rgb) ：设置颜色<br>getParent() ：返回 nil 或从 Wincontrol 类继承的对象<br>setParent(wincontrol) ：设置此控件的父级<br>getPopupMenu()<br>setPopupMenu()<br>getFont()：返回此对象的 Font 对象<br>setFont()：分配新的字体对象。 （不建议使用。如果要更改字体，请更改已存在的字体对象）<br>repaint()：使控件的图形区域无效并强制更新<br>update()：仅更新无效区域<br>setOnClick(functionnameorstring)：设置 onclick 例程<br>getOnClick()：获取 onclick 函数<br>doClick()：执行 onClick 下的当前函数<br>bringToFront()：更改控件的 z 顺序，使其位于顶部<br>sendToBack()：更改控件的 z 顺序，使其位于后面<br>screenToClient(x,y)：将屏幕 x,y 坐标转换为控件上的 x,y 坐标<br>clientToScreen(x,y)：将控件 x,y 坐标转换为屏幕坐标</p>
<p>GraphicsObject：（GraphicsObject-&gt;Object）</p>
<p>区域类：（区域-&gt;GraphicsObject-&gt;Object）<br>createRegion()：创建一个空区域</p>
<p>属性</p>
<p>方法<br>addRectangle(x1, y1, x2, y2)：向区域添加一个矩形<br>addPolygon(tablewithcoordinates)：添加一个 2D 位置数组。</p>
<p>WinControl 类：（继承：Control-&gt;Component-&gt;Object）<br>属性<br>句柄：整数 - 内部窗口句柄<br>DoubleBuffered：布尔值 - 图形更新将转到屏幕外的位图，然后显示在屏幕上，而不是直接显示在屏幕上。可以减少闪烁<br>ControlCount ：整数 - 此 wincontrol 的子控件数量<br>Control[] ：控件 - 用于访问子控件的数组<br>OnEnter ：函数 - WinControl 获得焦点时要调用的函数<br>OnExit ：函数 - WinControl 失去焦点时要调用的函数</p>
<p>方法<br>getControlCount() 返回附加到此类的控件数量<br>getControl(index) ：返回 WinControl 类对象<br>getControlAtPos(x,y)：获取相对于 wincontrol 位置的给定 x、y 位置处的控件<br>canFocus()：如果对象可以聚焦，则返回 true<br>focused()：聚焦时返回布尔值 true<br>setFocus()：尝试将键盘焦点设置为对象<br>setShape(Region)：将区域对象设置为此 wincontrol 的新形状<br>setShape(Bitmap)：<br>setOnEnter(function) ：设置 onEnter 事件。 （焦点进入时触发）<br>getOnEnter()<br>setOnExit(function) : 设置 onExit 事件。（失去焦点时触发）<br>getOnExit()<br>setLayeredAttributes(Key, Alpha, Flags) : 如果可能，设置控件的分层状态（Windows 7 及更早版本仅支持 Forms）<br>flags 可以是 LWA_ALPHA 和&#x2F;或 LWA_COLORKEY 的组合<br>有关更多信息，请参阅 msdn SetLayeredWindowAttributes</p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.mengkr.asia">Meng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.mengkr.asia/2024/10/03/CELua/">https://blog.mengkr.asia/2024/10/03/CELua/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.mengkr.asia" target="_blank">Meng's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/06/yolo/" title="yolov10"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-15805943.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">yolov10</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/29/Navidrome/" title="Navidrome自建音源"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-104351.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Navidrome自建音源</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">全局函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%B1%BB"><span class="toc-number">3.</span> <span class="toc-text">类</span></a></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Meng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>