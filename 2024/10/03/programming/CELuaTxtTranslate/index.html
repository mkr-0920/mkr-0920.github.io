<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>CELua.txt translate | Meng's blog</title><meta name="author" content="Meng"><meta name="copyright" content="Meng"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="翻译Cheat Engine的lua文档CELua.txt">
<meta property="og:type" content="article">
<meta property="og:title" content="CELua.txt translate">
<meta property="og:url" content="https://blog.010920.xyz/2024/10/03/programming/CELuaTxtTranslate/index.html">
<meta property="og:site_name" content="Meng&#39;s blog">
<meta property="og:description" content="翻译Cheat Engine的lua文档CELua.txt">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg">
<meta property="article:published_time" content="2024-10-03T13:50:45.000Z">
<meta property="article:modified_time" content="2025-10-04T01:22:57.451Z">
<meta property="article:author" content="Meng">
<meta property="article:tag" content="lua">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://blog.010920.xyz/2024/10/03/programming/CELuaTxtTranslate/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="stylesheet" href="/css/index.css?v=4.13.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: {"limitDay":365,"position":"top","messagePrev":"该文章最后更新于","messageNext":"天前，可能已经过时"},
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":200},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '天',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.1/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: true,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'CELua.txt translate',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2025-10-04 09:22:57'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.3.0"></head><body><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/./image/avatar.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">81</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">58</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">10</div></a></div><hr class="custom-hr"/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg')"><nav id="nav"><span id="blog-info"><a href="/" title="Meng's blog"><span class="site-name">Meng's blog</span></a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 归档</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">CELua.txt translate</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2024-10-03T13:50:45.000Z" title="发表于 2024-10-03 21:50:45">2024-10-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2025-10-04T01:22:57.451Z" title="更新于 2025-10-04 09:22:57">2025-10-04</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/programming/">programming</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/Reverse/">Reverse</a></span></div><div class="meta-secondline"></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="🌍-全局变量"><a href="#🌍-全局变量" class="headerlink" title="🌍 全局变量"></a>🌍 全局变量</h1><ul>
<li><code>TrainerOrigin</code>：仅当 CE 作为训练器启动时设置，包含启动 CE 的训练器路径。</li>
<li><code>process</code>：当前打开进程的主模块名称。</li>
<li><code>MainForm</code>：CE 主 GUI 窗口对象。</li>
<li><code>AddressList</code>：主 CE GUI 的地址列表对象。</li>
</ul>
<hr>
<h1 id="🧩-全局函数"><a href="#🧩-全局函数" class="headerlink" title="🧩 全局函数"></a>🧩 全局函数</h1><h2 id="版本与系统信息"><a href="#版本与系统信息" class="headerlink" title="版本与系统信息"></a>版本与系统信息</h2><ul>
<li><code>getCEVersion()</code>：返回 CE 版本的浮点值（如 7.4）。</li>
<li><code>getCheatEngineFileVersion()</code>：返回完整版本数据（原始整数 + 表：major, minor, release, build）。</li>
<li><code>getOperatingSystem()</code>：Windows 返回 0，Mac 返回 1。</li>
<li><code>darkMode()</code>：Windows 暗模式下返回 true（Mac 无影响）。</li>
</ul>
<h2 id="安全与保护"><a href="#安全与保护" class="headerlink" title="安全与保护"></a>安全与保护</h2><ul>
<li><code>activateProtection()</code>：防止基础内存扫描器打开 CE 进程（效果有限）。</li>
<li><code>enableDRM(altitude?, secondaryprocessid?)</code>：内核级保护，防止普通扫描器读取 CE 或指定进程内存。</li>
</ul>
<h2 id="内存操作"><a href="#内存操作" class="headerlink" title="内存操作"></a>内存操作</h2><ul>
<li><code>fullAccess(address, size)</code>：将内存块权限设为可写+可执行。</li>
<li><code>copyMemory(srcAddr, size, dstAddr?, method?)</code>：<ul>
<li>方法：0&#x3D;目标→目标，1&#x3D;目标→CE，2&#x3D;CE→目标，3&#x3D;CE→CE。</li>
<li>成功返回目标地址，失败返回 nil。</li>
</ul>
</li>
<li><code>compareMemory(addr1, addr2, size, method?)</code>：<ul>
<li>方法同上。相同返回 true，否则返回 false + 首次差异索引。</li>
</ul>
</li>
</ul>
<h2 id="读写内存（目标进程）"><a href="#读写内存（目标进程）" class="headerlink" title="读写内存（目标进程）"></a>读写内存（目标进程）</h2><ul>
<li><code>readBytes(addr, count, asTable?)</code>：读取字节，asTable&#x3D;true 时返回表。</li>
<li><code>writeBytes(addr, ...)</code> 或 <code>writeBytes(addr, table)</code>：写入字节。</li>
<li><code>readByte/Short/Integer/Qword/Pointer/Float/Double/String(addr, ...)</code>：读取各种类型。</li>
<li><code>writeByte/Short/Integer/Qword/Pointer/Float/Double/String(addr, value, ...)</code>：写入各种类型。<ul>
<li>所有写入函数成功返回 true。</li>
</ul>
</li>
</ul>
<h2 id="读写内存（CE-自身进程）"><a href="#读写内存（CE-自身进程）" class="headerlink" title="读写内存（CE 自身进程）"></a>读写内存（CE 自身进程）</h2><ul>
<li>所有上述函数均有 <code>Local</code> 后缀版本，如 <code>readBytesLocal</code>, <code>writeIntegerLocal</code> 等，操作 CE 自身内存。</li>
</ul>
<h2 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h2><ul>
<li><code>signExtend(value, msb)</code>：符号扩展。</li>
<li><code>xxxToByteTable(value)</code>：将数值&#x2F;字符串转为字节表（word, dword, qword, float, double, extended, string, wideString）。</li>
<li><code>byteTableToXxx(table, signed?)</code>：反向转换（word, dword, qword, float, double, extended, string, wideString）。</li>
</ul>
<h2 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h2><ul>
<li><code>bOr</code>, <code>bXor</code>, <code>bAnd</code>, <code>bShl</code>, <code>bShr</code>, <code>bNot</code>：标准位运算。</li>
</ul>
<h2 id="内存区域枚举与文件操作"><a href="#内存区域枚举与文件操作" class="headerlink" title="内存区域枚举与文件操作"></a>内存区域枚举与文件操作</h2><ul>
<li><code>enumMemoryRegions()</code>：返回内存布局表（BaseAddress, AllocationProtect, RegionSize 等）。</li>
<li><code>writeRegionToFile(filename, srcAddr, size)</code>：写内存块到文件。</li>
<li><code>readRegionFromFile(filename, dstAddr)</code>：从文件读取到内存。</li>
</ul>
<h2 id="Lua-状态与引用"><a href="#Lua-状态与引用" class="headerlink" title="Lua 状态与引用"></a>Lua 状态与引用</h2><ul>
<li><code>resetLuaState()</code>：创建新 Lua 状态（旧状态不销毁 → 内存泄漏）。</li>
<li><code>createRef(...)</code> → <code>getRef(id)</code> → <code>destroyRef(id)</code>：创建&#x2F;获取&#x2F;销毁 Lua 对象引用（用于存储非整数对象）。</li>
</ul>
<h2 id="函数序列化"><a href="#函数序列化" class="headerlink" title="函数序列化"></a>函数序列化</h2><ul>
<li><code>encodeFunction(fn)</code> → <code>decodeFunction(str)</code>：函数 ↔ 编码字符串（注意架构兼容性）。</li>
<li><code>encodeFunctionEx(script, dllPath?)</code>：支持指定 Lua DLL。</li>
</ul>
<h2 id="国际化"><a href="#国际化" class="headerlink" title="国际化"></a>国际化</h2><ul>
<li><code>getTranslationFolder()</code>：返回当前翻译路径。</li>
<li><code>loadPOFile(path)</code>：加载 .PO 翻译文件。</li>
<li><code>translate(str)</code> &#x2F; <code>translateID(id, orig?)</code>：翻译字符串。</li>
</ul>
<h2 id="字符编码"><a href="#字符编码" class="headerlink" title="字符编码"></a>字符编码</h2><ul>
<li><code>ansiToUtf8(str)</code> &#x2F; <code>utf8ToAnsi(str)</code>：编码转换（GUI 多用 UTF-8）。</li>
</ul>
<h2 id="模块与文件"><a href="#模块与文件" class="headerlink" title="模块与文件"></a>模块与文件</h2><ul>
<li><code>enumModules(pid?)</code>：返回模块信息表（Name, Address, Is64Bit, PathToFile）。</li>
<li><code>md5memory(addr, size)</code> &#x2F; <code>md5file(path)</code>：计算 MD5。</li>
<li><code>getFileVersion(path)</code>：返回文件版本（64位值 + 分段表）。</li>
<li><code>getFileList(path, mask?, subdirs?, attr?)</code> &#x2F; <code>getDirectoryList(path, subdirs?)</code>：文件&#x2F;目录枚举。</li>
<li><code>extractFileName/Ext/FileNameWithoutExt/FilePath(path)</code>：路径解析。</li>
</ul>
<h2 id="符号处理"><a href="#符号处理" class="headerlink" title="符号处理"></a>符号处理</h2><ul>
<li><code>enableWindowsSymbols()</code>：下载并加载 Windows PDB 符号（首次较慢）。</li>
<li><code>getAddress(symbol, local?)</code>：解析符号地址（local&#x3D;true 查询 CE 自身符号）。</li>
<li><code>enableKernelSymbols()</code>：启用内核符号（需先调用 enableWindowsSymbols）。</li>
<li><code>getAddressSafe(...)</code>：安全版 getAddress，失败返回 nil。</li>
<li><code>getSymbolInfo(symbol)</code>：返回符号信息表（modulename, address, size 等）。</li>
<li><code>getModuleSize(modulename)</code>：获取模块大小。</li>
<li><code>getRTTIClassName(addr)</code>：根据 RTTI 获取类名。</li>
<li><code>reinitializeSymbolhandler(wait?)</code>：重新初始化符号处理器。</li>
<li><code>searchPDBWhileLoading(state)</code>：是否在加载时查询 PDB（默认 false，较慢）。</li>
</ul>
<h2 id="错误与等待控制"><a href="#错误与等待控制" class="headerlink" title="错误与等待控制"></a>错误与等待控制</h2><ul>
<li><code>errorOnLookupFailure(state)</code>：查找失败时是否报错（默认 true）。</li>
<li><code>waitforsymbols(state)</code>：是否等待符号加载（默认 true）。</li>
</ul>
<h2 id="汇编与脚本"><a href="#汇编与脚本" class="headerlink" title="汇编与脚本"></a>汇编与脚本</h2><ul>
<li><code>generateAPIHookScript(addr, jumpTo, newCallAddr?, ext?, targetSelf?)</code>：生成 API Hook 脚本。</li>
<li><code>assemble(line, addr?, pref?, skipCheck?)</code>：汇编单行代码。</li>
<li><code>autoAssemble(text, targetSelf?, disableInfo?)</code>：执行自动汇编脚本。</li>
<li><code>autoAssembleCheck(text, enable, targetSelf?)</code>：语法检查。</li>
<li><code>compile(text, addr?, targetSelf?)</code>：编译 C 代码 → 返回符号表。</li>
<li><code>compileCS(text, refs, coreAssembly?)</code>：编译 C# 代码 → 返回临时 DLL 路径。</li>
</ul>
<h2 id="EXE-训练器与自定义命令"><a href="#EXE-训练器与自定义命令" class="headerlink" title="EXE 训练器与自定义命令"></a>EXE 训练器与自定义命令</h2><ul>
<li><code>registerEXETrainerFeature(name, fn)</code>：向 EXE 训练器添加功能。</li>
<li><code>registerAutoAssemblerCommand(cmd, fn)</code>：注册自定义 AA 命令。</li>
<li><code>registerLuaFunctionHighlight(name)</code>：高亮指定函数名。</li>
</ul>
<h2 id="符号-结构回调"><a href="#符号-结构回调" class="headerlink" title="符号&#x2F;结构回调"></a>符号&#x2F;结构回调</h2><ul>
<li><code>registerSymbolLookupCallback(fn, location)</code>：符号解析时回调。</li>
<li><code>registerAddressLookupCallback(fn)</code>：地址转名称回调。</li>
<li><code>registerStructureAndElementListCallback(structFn, elemFn)</code>：自定义结构剖析。</li>
<li><code>registerStructureDissectOverride(fn)</code>：覆盖自动结构猜测。</li>
<li><code>registerStructureNameLookup(fn)</code>：自定义结构命名。</li>
</ul>
<h2 id="汇编器覆盖"><a href="#汇编器覆盖" class="headerlink" title="汇编器覆盖"></a>汇编器覆盖</h2><ul>
<li><code>registerAssembler(fn)</code>：自定义单行汇编器。</li>
<li><code>registerAutoAssemblerPrologue(fn, postAOB?)</code>：AA 脚本预处理。</li>
</ul>
<h2 id="脚本模板与注入"><a href="#脚本模板与注入" class="headerlink" title="脚本模板与注入"></a>脚本模板与注入</h2><ul>
<li><code>registerAutoAssemblerTemplate(name, fn, shortcut?)</code>：注册 AA 模板。</li>
<li><code>generateCodeInjectionScript(script, addr, farjmp?)</code>：生成代码注入脚本。</li>
<li><code>generateAOBInjectionScript(script, sym, addr, radius?, farjmp?)</code>：生成 AOB 注入脚本。</li>
<li><code>getNextAllocNumber(script)</code>：获取下一个可用 alloc 编号。</li>
<li><code>getUniqueAOB(addr)</code>：扫描唯一 AOB 并返回字符串 + 偏移。</li>
</ul>
<h2 id="UI-交互"><a href="#UI-交互" class="headerlink" title="UI 交互"></a>UI 交互</h2><ul>
<li><code>showMessage(text)</code>：显示消息框。</li>
<li><code>inputQuery(caption, prompt, init)</code>：输入对话框。</li>
<li><code>showSelectionList(title, caption, list, allowCustom?)</code>：选择列表。</li>
<li><code>messageDialog(text, type, buttons...)</code>：自定义消息框。</li>
<li><code>sleep(ms)</code>：暂停毫秒数。</li>
</ul>
<h2 id="进程与窗口"><a href="#进程与窗口" class="headerlink" title="进程与窗口"></a>进程与窗口</h2><ul>
<li><code>getProcesslist()</code>：返回进程表（pid - name）。</li>
<li><code>getWindowlist()</code>：返回窗口表（pid - {id, caption}）。</li>
<li><code>getThreadlist(list)</code>：填充线程列表。</li>
<li><code>getHandleList(filter?)</code>：返回句柄表（filter: 0&#x3D;all, 1&#x3D;target, 2→target, 3→CE）。</li>
<li><code>closeRemoteHandle(handle, pid?)</code>：关闭远程句柄。</li>
<li><code>duplicateHandle(handle, mode?/fromPID, toPID?)</code>：复制句柄。</li>
</ul>
<h2 id="进程事件"><a href="#进程事件" class="headerlink" title="进程事件"></a>进程事件</h2><ul>
<li><code>onOpenProcess(pid)</code>：进程打开时调用（可能多次）。</li>
<li><code>MainForm.OnProcessOpened(pid, handle, caption)</code>：推荐替代 onOpenProcess（主线程单次调用）。</li>
</ul>
<h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><ul>
<li><code>getOpenedProcessID()</code> &#x2F; <code>getOpenedProcessHandle()</code>：获取当前进程。</li>
<li><code>openProcess(pid/name)</code>：打开进程。</li>
<li><code>openFileAsProcess(filename, is64?, startAddr?)</code>：以进程方式打开文件。</li>
<li><code>saveOpenedFile(filename?)</code>：保存文件更改。</li>
<li><code>setPointerSize(size)</code>：设置指针大小（字节）。</li>
<li><code>setAssemblerMode(0=32bit, 1=64bit)</code>。</li>
<li><code>pause()</code> &#x2F; <code>unpause()</code>：暂停&#x2F;恢复进程。</li>
</ul>
<h2 id="系统信息"><a href="#系统信息" class="headerlink" title="系统信息"></a>系统信息</h2><ul>
<li><code>getCPUCount()</code>：CPU 核心数。</li>
<li><code>cpuid(eax, ecx)</code>：返回 CPUID 表（eax, ebx, ecx, edx）。</li>
<li><code>gc_setPassive(state)</code> &#x2F; <code>gc_setActive(state, interval, minsize)</code>：控制垃圾回收。</li>
<li><code>getSystemMetrics(index)</code>：获取系统指标（参见 MSDN）。</li>
<li><code>getScreenDPI()</code> &#x2F; <code>getScreenHeight()</code> &#x2F; <code>getScreenWidth()</code>：屏幕信息。</li>
<li><code>getWorkAreaHeight()</code> &#x2F; <code>getWorkAreaWidth()</code>：工作区尺寸。</li>
<li><code>getScreenCanvas()</code>：获取屏幕画布（谨慎使用）。</li>
<li><code>getPixel(x,y)</code>：获取屏幕像素 RGB。</li>
<li><code>getMousePos()</code> &#x2F; <code>setMousePos(x,y)</code>：鼠标位置。</li>
<li><code>isKeyPressed(key)</code> &#x2F; <code>keyDown(key)</code> &#x2F; <code>keyUp(key)</code> &#x2F; <code>doKeyPress(key)</code>：键盘模拟。</li>
<li><code>mouse_event(flags, x?, y?, data?, extra?)</code>：鼠标事件 API。</li>
<li><code>shortCutToText(sc)</code> &#x2F; <code>textToShortCut(str)</code>：快捷键转换（6.4+）。</li>
<li><code>convertKeyComboToString(key1,...)</code>：键组合转字符串。</li>
<li><code>outputDebugString(text)</code>：输出调试信息（可用 DbgView 查看）。</li>
<li><code>shellExecute(cmd, params?, folder?, showcmd?)</code>：执行命令。</li>
<li><code>getTickCount()</code>：系统启动毫秒数。</li>
<li><code>processMessages()</code>：处理 GUI 消息（防冻结）。</li>
<li><code>inMainThread()</code>：是否在主线程（6.4+）。</li>
<li><code>integerToUserData(int)</code> &#x2F; <code>userDataToInteger(ud)</code>：整数 ↔ UserData 转换。</li>
<li><code>synchronize(fn, ...)</code>：主线程同步调用。</li>
<li><code>queue(fn, ...)</code> + <code>checkSynchronize(timeout?)</code>：异步调用 + 检查。</li>
<li><code>writeToClipboard(text)</code> &#x2F; <code>readFromClipboard()</code>：剪贴板操作。</li>
</ul>
<h2 id="速度与注入"><a href="#速度与注入" class="headerlink" title="速度与注入"></a>速度与注入</h2><ul>
<li><code>speedhack_setSpeed(speed)</code> &#x2F; <code>speedhack_getSpeed()</code>：设置&#x2F;获取速度倍率。</li>
<li><code>injectDLL(filename, skipWait?)</code> &#x2F; <code>injectLibrary(...)</code>：注入 DLL。</li>
<li><code>injectDotNetDLL(dll, class, method, params, timeout?)</code>：注入 .NET DLL 并调用静态方法。</li>
</ul>
<h2 id="代码执行"><a href="#代码执行" class="headerlink" title="代码执行"></a>代码执行</h2><ul>
<li><code>executeCode(addr, param?, timeout?)</code>：在目标进程执行 stdcall 函数。</li>
<li><code>executeCodeLocal(addr, param?)</code>：在 CE 进程执行。</li>
<li><code>executeCodeEx(callmethod, timeout, addr, &#123;type,val&#125;...)</code>：带参数执行（支持多种类型）。</li>
<li><code>executeMethod(callmethod, timeout, addr, &#123;regnr,class&#125;, params...)</code>：执行类方法（指定寄存器）。</li>
</ul>
<h2 id="插件与字体"><a href="#插件与字体" class="headerlink" title="插件与字体"></a>插件与字体</h2><ul>
<li><code>loadPlugin(dll)</code>：加载插件。</li>
<li><code>loadFontFromStream(stream)</code> → <code>unloadLoadedFont(id)</code>：从流加载字体。</li>
</ul>
<h2 id="自动猜测与窗口控制"><a href="#自动猜测与窗口控制" class="headerlink" title="自动猜测与窗口控制"></a>自动猜测与窗口控制</h2><ul>
<li><code>onAutoGuess(fn)</code>：注册变量类型猜测回调。</li>
<li><code>closeCE()</code>：关闭 CE。</li>
<li><code>hideAllCEWindows()</code> &#x2F; <code>unhideMainCEwindow()</code>：隐藏&#x2F;显示 CE 窗口。</li>
</ul>
<h2 id="内存扫描"><a href="#内存扫描" class="headerlink" title="内存扫描"></a>内存扫描</h2><ul>
<li><code>AOBScan(bytes...)</code> &#x2F; <code>AOBScan(&quot;aob&quot;, prot?, alignType?, alignParam?)</code>：扫描 AOB。</li>
<li><code>AOBScanUnique(...)</code> &#x2F; <code>AOBScanModuleUnique(module, ...)</code>：扫描唯一结果。</li>
</ul>
<h2 id="内存分配"><a href="#内存分配" class="headerlink" title="内存分配"></a>内存分配</h2><ul>
<li><code>allocateMemory(size, base?, prot?)</code>：分配目标进程内存。</li>
<li><code>deAlloc(addr, size?)</code>：释放内存。</li>
<li><code>allocateSharedMemory(name, size?)</code>：创建共享内存（跨进程）。</li>
<li><code>createSection(size)</code> → <code>mapViewOfSection(sec, base?)</code> → <code>unMapViewOfSection(addr)</code>：内存映射。</li>
</ul>
<h2 id="窗口操作"><a href="#窗口操作" class="headerlink" title="窗口操作"></a>窗口操作</h2><ul>
<li><code>getForegroundProcess()</code>：获取前台进程 PID。</li>
<li><code>findWindow(class?, caption?)</code>：查找窗口句柄。</li>
<li><code>getWindow(hwnd, cmd)</code> &#x2F; <code>getWindowCaption/ClassName/ProcessID(hwnd)</code>：窗口信息。</li>
<li><code>getForegroundWindow()</code>：获取前台窗口句柄。</li>
<li><code>sendMessage(hwnd, msg, wparam, lparam)</code>：发送窗口消息。</li>
<li><code>hookWndProc(hwnd, fn, async?)</code> → <code>unhookWndProc(hwnd)</code>：挂钩窗口过程。</li>
</ul>
<h2 id="系统架构"><a href="#系统架构" class="headerlink" title="系统架构"></a>系统架构</h2><ul>
<li><code>cheatEngineIs64Bit()</code> &#x2F; <code>targetIs64Bit()</code>：判断 CE&#x2F;目标是否为 64 位。</li>
<li><code>getCheatEngineDir()</code>：CE 安装目录。</li>
<li><code>getCheatEngineProcessID()</code>：CE 自身 PID。</li>
<li><code>getAutorunPath()</code> &#x2F; <code>getUserDocumentsPath()</code>：路径获取。</li>
</ul>
<h2 id="反汇编"><a href="#反汇编" class="headerlink" title="反汇编"></a>反汇编</h2><ul>
<li><code>disassemble(addr)</code>：反汇编 → “地址 - 字节 - 操作码”。</li>
<li><code>splitDisassembledString(str)</code>：拆分为地址、字节、操作码、extra。</li>
<li><code>getInstructionSize(addr)</code>：获取指令大小。</li>
<li><code>getPreviousOpcode(addr)</code>：获取前一条指令地址（估算）。</li>
</ul>
<h2 id="音频与语音"><a href="#音频与语音" class="headerlink" title="音频与语音"></a>音频与语音</h2><ul>
<li><code>beep()</code>：播放提示音。</li>
<li><code>playSound(stream/tablefile, wait?)</code>：播放 WAV（支持内置 “Activate”&#x2F;“Deactivate”）。</li>
<li><code>speak(text, wait?)</code> &#x2F; <code>speak(text, flags)</code>：文本转语音（支持 SSML）。</li>
<li><code>speakEnglish(text, wait?)</code>：强制英语语音。</li>
</ul>
<h2 id="实用函数"><a href="#实用函数" class="headerlink" title="实用函数"></a>实用函数</h2><ul>
<li><code>printf(...)</code> &#x3D; <code>print(string.format(...))</code>。</li>
<li><code>setProgressState(state)</code> &#x2F; <code>setProgressValue(cur, max)</code>：任务栏进度（Windows）。</li>
<li><code>getUserRegistryEnvironmentVariable(name)</code> &#x2F; <code>setUserRegistryEnvironmentVariable(name, val)</code>：用户环境变量。</li>
<li><code>stringToMD5String(str)</code>：字符串 → MD5。</li>
<li><code>getFormCount()</code> &#x2F; <code>getForm(index)</code>：获取 CE 窗体。</li>
<li><code>registerFormAddNotification(fn)</code> → <code>unregister...</code>：窗体创建通知。</li>
<li><code>getSettingsForm()</code> &#x2F; <code>getMemoryViewForm()</code> &#x2F; <code>getMainForm()</code>：常用窗体。</li>
<li><code>getApplication()</code> &#x2F; <code>getAddressList()</code> &#x2F; <code>getFreezeTimer()</code> &#x2F; <code>getUpdateTimer()</code>：核心对象。</li>
<li><code>setGlobalKeyPollInterval(ms)</code>：全局按键轮询间隔。</li>
<li><code>setGlobalDelayBetweenHotkeyActivation(ms)</code>：热键最小间隔。</li>
</ul>
<h2 id="Xbox-360-控制器"><a href="#Xbox-360-控制器" class="headerlink" title="Xbox 360 控制器"></a>Xbox 360 控制器</h2><ul>
<li><code>getXBox360ControllerState(id?)</code>：获取控制器状态（按钮、摇杆、扳机）。</li>
<li><code>setXBox360ControllerVibration(id, left, right)</code>：设置振动（0-65535）。</li>
</ul>
<h2 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h2><ul>
<li><code>connectToCEServer(host, port)</code>：连接到 CE 服务器（后续命令由服务器处理）。</li>
</ul>
<h2 id="属性反射（Pascal-类）"><a href="#属性反射（Pascal-类）" class="headerlink" title="属性反射（Pascal 类）"></a>属性反射（Pascal 类）</h2><ul>
<li><code>getPropertyList(class)</code>：获取类的已发布属性列表。</li>
<li><code>setProperty(class, prop, val)</code> &#x2F; <code>getProperty(class, prop)</code>：设置&#x2F;获取属性。</li>
<li><code>setMethodProperty(class, prop, fn)</code> &#x2F; <code>getMethodProperty(class, prop)</code>：设置&#x2F;获取方法属性。</li>
</ul>
<h2 id="符号注册"><a href="#符号注册" class="headerlink" title="符号注册"></a>符号注册</h2><ul>
<li><code>registerSymbol(name, addr, donotsave?)</code> &#x2F; <code>unregisterSymbol(name)</code>：用户符号管理。</li>
<li><code>getNameFromAddress(addr, mod?, sym?, sec?)</code>：地址 → 符号&#x2F;模块名。</li>
<li><code>inModule(addr)</code> &#x2F; <code>inSystemModule(addr)</code>：判断地址是否在模块内。</li>
<li><code>getCommonModuleList()</code>：获取通用模块列表。</li>
</ul>
<h2 id="AOB-扫描参数详解"><a href="#AOB-扫描参数详解" class="headerlink" title="AOB 扫描参数详解"></a>AOB 扫描参数详解</h2><ul>
<li><code>protectionflags</code>：字符串，如 “+W-C”（可写、非写时复制）。</li>
<li><code>alignmenttype</code>：0&#x3D;无，1&#x3D;整除，2&#x3D;结尾匹配。</li>
<li><code>alignmentparam</code>：对齐参数值。</li>
</ul>
<hr>
<h1 id="🐞-调试相关"><a href="#🐞-调试相关" class="headerlink" title="🐞 调试相关"></a>🐞 调试相关</h1><h2 id="调试寄存器（全局变量）"><a href="#调试寄存器（全局变量）" class="headerlink" title="调试寄存器（全局变量）"></a>调试寄存器（全局变量）</h2><ul>
<li>32&#x2F;64 位：EAX, EBX, ECX, EDX, ESI, EDI, EBP, ESP, EIP</li>
<li>64 位额外：RAX, RBX, …, R15</li>
<li><code>EFLAGS</code>：标志寄存器</li>
</ul>
<h2 id="调试函数"><a href="#调试函数" class="headerlink" title="调试函数"></a>调试函数</h2><ul>
<li><code>debugger_onBreakpoint()</code>：断点命中时调用（填充寄存器），返回 0 刷新 UI。</li>
<li><code>createProcess(path, params?, debug?, breakOnEntry?)</code>：创建调试进程。</li>
<li><code>debugProcess(interface?)</code>：启动调试器（0&#x3D;默认, 1&#x3D;Windows, 2&#x3D;VEH, 3&#x3D;Kernel）。</li>
<li><code>debug_isDebugging()</code> &#x2F; <code>debug_getCurrentDebuggerInterface()</code>：调试状态。</li>
<li><code>debug_canBreak()</code> &#x2F; <code>debug_isBroken()</code>：能否&#x2F;是否中断。</li>
<li><code>debug_getBreakpointList()</code>：获取断点列表。</li>
<li><code>debug_breakThread(tid)</code>：中断指定线程。</li>
<li><code>debug_addThreadToNoBreakList(tid)</code> &#x2F; <code>debug_remove...</code>：忽略线程断点。</li>
<li><code>debug_setBreakpoint(addr, size?, trigger?, method?, fn?)</code>：设置断点。</li>
<li><code>debug_removeBreakpoint(addr)</code>：移除断点。</li>
<li><code>debug_continueFromBreakpoint(method)</code>：继续执行（co_run, co_stepinto, co_stepover）。</li>
<li><code>debug_getXMMPointer(reg)</code>：获取 XMM 寄存器地址（CE 本地内存）。</li>
</ul>
<h2 id="最后分支记录（仅-Kernel-XP）"><a href="#最后分支记录（仅-Kernel-XP）" class="headerlink" title="最后分支记录（仅 Kernel + XP）"></a>最后分支记录（仅 Kernel + XP）</h2><ul>
<li><code>debug_setLastBranchRecording(bool)</code>：启用记录。</li>
<li><code>debug_getMaxLastBranchRecord()</code>：最大记录数。</li>
<li><code>debug_getLastBranchRecord(index)</code>：获取记录。</li>
</ul>
<h2 id="模块加载事件"><a href="#模块加载事件" class="headerlink" title="模块加载事件"></a>模块加载事件</h2><ul>
<li><code>debugger_onModuleLoad(name, base)</code>：模块加载时调用，返回 1 可中断。</li>
</ul>
<h2 id="上下文操作"><a href="#上下文操作" class="headerlink" title="上下文操作"></a>上下文操作</h2><ul>
<li><code>debug_getContext(extra?)</code> &#x2F; <code>debug_setContext(extra?)</code>：获取&#x2F;设置寄存器上下文。</li>
<li><code>debug_updateGUI()</code>：刷新调试 UI。</li>
</ul>
<h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><ul>
<li><code>detachIfPossible()</code>：分离调试器。</li>
<li><code>getComment(addr)</code> &#x2F; <code>setComment(addr, text)</code>：地址注释。</li>
<li><code>getHeader(addr)</code> &#x2F; <code>setHeader(addr, text)</code>：地址头部。</li>
</ul>
<h2 id="BinUtils-支持"><a href="#BinUtils-支持" class="headerlink" title="BinUtils 支持"></a>BinUtils 支持</h2><ul>
<li><code>registerBinUtil(config)</code>：注册其他架构汇编器（如 ARM）。<ul>
<li>config: {name, desc, arch, ASParam, LDParam, OBJDUMPParam, OnDisassemble, path, prefix, DisassemblerCommentChar}</li>
</ul>
</li>
</ul>
<hr>
<h1 id="🧱-类参考"><a href="#🧱-类参考" class="headerlink" title="🧱 类参考"></a>🧱 类参考</h1><h2 id="Control-类（继承-Component-→-Object）"><a href="#Control-类（继承-Component-→-Object）" class="headerlink" title="Control 类（继承 Component → Object）"></a>Control 类（继承 Component → Object）</h2><p><strong>属性</strong>：</p>
<ul>
<li><code>Caption</code>, <code>Top</code>, <code>Left</code>, <code>Width</code>, <code>Height</code>, <code>ClientWidth</code>, <code>ClientHeight</code></li>
<li><code>Align</code>, <code>Enabled</code>, <code>Visible</code>, <code>Color</code>, <code>RGBColor</code>, <code>Parent</code>, <code>PopupMenu</code>, <code>Font</code></li>
<li><code>OnClick</code>, <code>OnChangeBounds</code></li>
</ul>
<p><strong>方法</strong>：</p>
<ul>
<li><code>setPosition(x,y)</code>, <code>getSize()</code>, <code>setAlign(...)</code>, <code>setEnabled(bool)</code>, <code>setVisible(bool)</code></li>
<li><code>setColor(rgb)</code>, <code>setParent(wincontrol)</code>, <code>getFont()</code>, <code>repaint()</code>, <code>update()</code></li>
<li><code>setOnClick(fn)</code>, <code>doClick()</code>, <code>bringToFront()</code>, <code>sendToBack()</code></li>
<li><code>screenToClient(x,y)</code>, <code>clientToScreen(x,y)</code></li>
</ul>
<hr>
<h2 id="Region-类（继承-GraphicsObject-→-Object）"><a href="#Region-类（继承-GraphicsObject-→-Object）" class="headerlink" title="Region 类（继承 GraphicsObject → Object）"></a>Region 类（继承 GraphicsObject → Object）</h2><ul>
<li><code>createRegion()</code>：创建空区域。</li>
<li><code>addRectangle(x1,y1,x2,y2)</code>：添加矩形。</li>
<li><code>addPolygon(&#123;x1,y1,x2,y2,...&#125;)</code>：添加多边形。</li>
</ul>
<hr>
<h2 id="WinControl-类（继承-Control-→-Component-→-Object）"><a href="#WinControl-类（继承-Control-→-Component-→-Object）" class="headerlink" title="WinControl 类（继承 Control → Component → Object）"></a>WinControl 类（继承 Control → Component → Object）</h2><p><strong>属性</strong>：</p>
<ul>
<li><code>Handle</code>, <code>DoubleBuffered</code>, <code>ControlCount</code>, <code>Control[]</code>, <code>OnEnter</code>, <code>OnExit</code></li>
</ul>
<p><strong>方法</strong>：</p>
<ul>
<li><code>getControlCount()</code>, <code>getControl(index)</code>, <code>getControlAtPos(x,y)</code></li>
<li><code>canFocus()</code>, <code>focused()</code>, <code>setFocus()</code></li>
<li><code>setShape(Region/Bitmap)</code></li>
<li><code>setOnEnter(fn)</code>, <code>setOnExit(fn)</code></li>
<li><code>setLayeredAttributes(key, alpha, flags)</code>：设置分层属性（LWA_ALPHA, LWA_COLORKEY）</li>
</ul>
<hr>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://blog.010920.xyz">Meng</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://blog.010920.xyz/2024/10/03/programming/CELuaTxtTranslate/">https://blog.010920.xyz/2024/10/03/programming/CELuaTxtTranslate/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://blog.010920.xyz" target="_blank">Meng's blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/lua/">lua</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-456710.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2024/10/06/yolo/" title="yolov10"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-15805943.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">yolov10</div></div></a></div><div class="next-post pull-right"><a href="/2024/09/16/nginx-uci/" title="uci管理nginx"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-30247928.jpeg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">uci管理nginx</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/2025/06/15/programming/CELua/" title="CT表的Lua脚本"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/Cheat_Engine_Logo.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-06-15</div><div class="title">CT表的Lua脚本</div></div></a></div><div><a href="/2024/09/01/programming/gglua/" title="gameguardian"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/pexels-photo-30002066.jpeg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2024-09-01</div><div class="title">gameguardian</div></div></a></div><div><a href="/2025/07/10/programming/lua/" title="lua"><img class="cover" src="https://cdn.jsdelivr.net/gh/mkr-0920/BlogImage/img/600px-Lua-Logo.svg.png" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2025-07-10</div><div class="title">lua</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%8C%8D-%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.</span> <span class="toc-text">🌍 全局变量</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%A9-%E5%85%A8%E5%B1%80%E5%87%BD%E6%95%B0"><span class="toc-number">2.</span> <span class="toc-text">🧩 全局函数</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%88%E6%9C%AC%E4%B8%8E%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.1.</span> <span class="toc-text">版本与系统信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%89%E5%85%A8%E4%B8%8E%E4%BF%9D%E6%8A%A4"><span class="toc-number">2.2.</span> <span class="toc-text">安全与保护</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%93%8D%E4%BD%9C"><span class="toc-number">2.3.</span> <span class="toc-text">内存操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%EF%BC%88%E7%9B%AE%E6%A0%87%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">2.4.</span> <span class="toc-text">读写内存（目标进程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%AF%BB%E5%86%99%E5%86%85%E5%AD%98%EF%BC%88CE-%E8%87%AA%E8%BA%AB%E8%BF%9B%E7%A8%8B%EF%BC%89"><span class="toc-number">2.5.</span> <span class="toc-text">读写内存（CE 自身进程）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">2.6.</span> <span class="toc-text">数据类型转换</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BD%8D%E8%BF%90%E7%AE%97"><span class="toc-number">2.7.</span> <span class="toc-text">位运算</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E6%9E%9A%E4%B8%BE%E4%B8%8E%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C"><span class="toc-number">2.8.</span> <span class="toc-text">内存区域枚举与文件操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Lua-%E7%8A%B6%E6%80%81%E4%B8%8E%E5%BC%95%E7%94%A8"><span class="toc-number">2.9.</span> <span class="toc-text">Lua 状态与引用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%87%BD%E6%95%B0%E5%BA%8F%E5%88%97%E5%8C%96"><span class="toc-number">2.10.</span> <span class="toc-text">函数序列化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BD%E9%99%85%E5%8C%96"><span class="toc-number">2.11.</span> <span class="toc-text">国际化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AD%97%E7%AC%A6%E7%BC%96%E7%A0%81"><span class="toc-number">2.12.</span> <span class="toc-text">字符编码</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E4%B8%8E%E6%96%87%E4%BB%B6"><span class="toc-number">2.13.</span> <span class="toc-text">模块与文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E5%A4%84%E7%90%86"><span class="toc-number">2.14.</span> <span class="toc-text">符号处理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%94%99%E8%AF%AF%E4%B8%8E%E7%AD%89%E5%BE%85%E6%8E%A7%E5%88%B6"><span class="toc-number">2.15.</span> <span class="toc-text">错误与等待控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E4%B8%8E%E8%84%9A%E6%9C%AC"><span class="toc-number">2.16.</span> <span class="toc-text">汇编与脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#EXE-%E8%AE%AD%E7%BB%83%E5%99%A8%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E5%91%BD%E4%BB%A4"><span class="toc-number">2.17.</span> <span class="toc-text">EXE 训练器与自定义命令</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7-%E7%BB%93%E6%9E%84%E5%9B%9E%E8%B0%83"><span class="toc-number">2.18.</span> <span class="toc-text">符号&#x2F;结构回调</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%B1%87%E7%BC%96%E5%99%A8%E8%A6%86%E7%9B%96"><span class="toc-number">2.19.</span> <span class="toc-text">汇编器覆盖</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%84%9A%E6%9C%AC%E6%A8%A1%E6%9D%BF%E4%B8%8E%E6%B3%A8%E5%85%A5"><span class="toc-number">2.20.</span> <span class="toc-text">脚本模板与注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#UI-%E4%BA%A4%E4%BA%92"><span class="toc-number">2.21.</span> <span class="toc-text">UI 交互</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%AA%97%E5%8F%A3"><span class="toc-number">2.22.</span> <span class="toc-text">进程与窗口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E4%BA%8B%E4%BB%B6"><span class="toc-number">2.23.</span> <span class="toc-text">进程事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6"><span class="toc-number">2.24.</span> <span class="toc-text">进程控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E4%BF%A1%E6%81%AF"><span class="toc-number">2.25.</span> <span class="toc-text">系统信息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%9F%E5%BA%A6%E4%B8%8E%E6%B3%A8%E5%85%A5"><span class="toc-number">2.26.</span> <span class="toc-text">速度与注入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C"><span class="toc-number">2.27.</span> <span class="toc-text">代码执行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E4%BB%B6%E4%B8%8E%E5%AD%97%E4%BD%93"><span class="toc-number">2.28.</span> <span class="toc-text">插件与字体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%8C%9C%E6%B5%8B%E4%B8%8E%E7%AA%97%E5%8F%A3%E6%8E%A7%E5%88%B6"><span class="toc-number">2.29.</span> <span class="toc-text">自动猜测与窗口控制</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%89%AB%E6%8F%8F"><span class="toc-number">2.30.</span> <span class="toc-text">内存扫描</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D"><span class="toc-number">2.31.</span> <span class="toc-text">内存分配</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AA%97%E5%8F%A3%E6%93%8D%E4%BD%9C"><span class="toc-number">2.32.</span> <span class="toc-text">窗口操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%B3%BB%E7%BB%9F%E6%9E%B6%E6%9E%84"><span class="toc-number">2.33.</span> <span class="toc-text">系统架构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%8D%E6%B1%87%E7%BC%96"><span class="toc-number">2.34.</span> <span class="toc-text">反汇编</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%9F%B3%E9%A2%91%E4%B8%8E%E8%AF%AD%E9%9F%B3"><span class="toc-number">2.35.</span> <span class="toc-text">音频与语音</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AE%9E%E7%94%A8%E5%87%BD%E6%95%B0"><span class="toc-number">2.36.</span> <span class="toc-text">实用函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Xbox-360-%E6%8E%A7%E5%88%B6%E5%99%A8"><span class="toc-number">2.37.</span> <span class="toc-text">Xbox 360 控制器</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BD%91%E7%BB%9C"><span class="toc-number">2.38.</span> <span class="toc-text">网络</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B1%9E%E6%80%A7%E5%8F%8D%E5%B0%84%EF%BC%88Pascal-%E7%B1%BB%EF%BC%89"><span class="toc-number">2.39.</span> <span class="toc-text">属性反射（Pascal 类）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%A6%E5%8F%B7%E6%B3%A8%E5%86%8C"><span class="toc-number">2.40.</span> <span class="toc-text">符号注册</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AOB-%E6%89%AB%E6%8F%8F%E5%8F%82%E6%95%B0%E8%AF%A6%E8%A7%A3"><span class="toc-number">2.41.</span> <span class="toc-text">AOB 扫描参数详解</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%90%9E-%E8%B0%83%E8%AF%95%E7%9B%B8%E5%85%B3"><span class="toc-number">3.</span> <span class="toc-text">🐞 调试相关</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%AF%84%E5%AD%98%E5%99%A8%EF%BC%88%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F%EF%BC%89"><span class="toc-number">3.1.</span> <span class="toc-text">调试寄存器（全局变量）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B0%83%E8%AF%95%E5%87%BD%E6%95%B0"><span class="toc-number">3.2.</span> <span class="toc-text">调试函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%90%8E%E5%88%86%E6%94%AF%E8%AE%B0%E5%BD%95%EF%BC%88%E4%BB%85-Kernel-XP%EF%BC%89"><span class="toc-number">3.3.</span> <span class="toc-text">最后分支记录（仅 Kernel + XP）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A8%A1%E5%9D%97%E5%8A%A0%E8%BD%BD%E4%BA%8B%E4%BB%B6"><span class="toc-number">3.4.</span> <span class="toc-text">模块加载事件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%8A%E4%B8%8B%E6%96%87%E6%93%8D%E4%BD%9C"><span class="toc-number">3.5.</span> <span class="toc-text">上下文操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B6%E4%BB%96"><span class="toc-number">3.6.</span> <span class="toc-text">其他</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#BinUtils-%E6%94%AF%E6%8C%81"><span class="toc-number">3.7.</span> <span class="toc-text">BinUtils 支持</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%F0%9F%A7%B1-%E7%B1%BB%E5%8F%82%E8%80%83"><span class="toc-number">4.</span> <span class="toc-text">🧱 类参考</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Control-%E7%B1%BB%EF%BC%88%E7%BB%A7%E6%89%BF-Component-%E2%86%92-Object%EF%BC%89"><span class="toc-number">4.1.</span> <span class="toc-text">Control 类（继承 Component → Object）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Region-%E7%B1%BB%EF%BC%88%E7%BB%A7%E6%89%BF-GraphicsObject-%E2%86%92-Object%EF%BC%89"><span class="toc-number">4.2.</span> <span class="toc-text">Region 类（继承 GraphicsObject → Object）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#WinControl-%E7%B1%BB%EF%BC%88%E7%BB%A7%E6%89%BF-Control-%E2%86%92-Component-%E2%86%92-Object%EF%BC%89"><span class="toc-number">4.3.</span> <span class="toc-text">WinControl 类（继承 Control → Component → Object）</span></a></li></ol></li></ol></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2025 By Meng</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.13.0"></script><script src="/js/main.js?v=4.13.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.33/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div></div></body></html>